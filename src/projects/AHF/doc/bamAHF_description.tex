% Description of the AHFinder of Jose Gonzalez
% Norbert Lages 12/07
%
\documentclass[11pt,a4paper,twoside]{article}
%
\usepackage{amsmath}          % some math extensions
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{txfonts}
\usepackage{graphicx}
\usepackage{dsfont}
%\usepackage{fancyhdr}
%
%\DeclareMathOperator{\trace}{\,tr\,}
\DeclareMathOperator{\upd}{d\!}
%
\begin{document}
%
\newcommand*\person[1]{\textsc{#1}}
\newcommand*\GansFuss[1]{"`#1"'}
%
\newcommand*\Gam[2]{\ensuremath{\Gamma^{#1}_{#2}}}
\newcommand*\pgam[3]{\ensuremath{\partial_{#1} \gamma^{#2}_{#3}}}
\newcommand*\warningsymbol{\;\Large{\textbf{!}}\;\normalsize}
%
%
% Paragraphs with vertical distance
\parskip0.9ex plus1ex minus0.5ex
%
%
\title{Description of the AH-Finder of Jos\'e A. Gonz\'alez in BAM}
\author{Norbert Lages}
\maketitle

\section{Introduction}
The apparent horizon finder follows mainly the route of Gundlach
\cite{Gundlach:1997us} and Alcubierre \cite{Alcubierre:1998rq}. 
The program calculates the 
apparent horizon as a height function around a center.
This height function can be given by values $h(\theta,\phi)$ at discrete
values for $\theta$ and $\phi$ or by expansion into spherical harmonics:
\begin{equation}
  h(\theta,\phi) = \sqrt{4\pi} \sum_{l=0}^{l_{max}} 
                  \sum_{m=-l}^{l} a_{lm} Y_{lm}(\theta,\phi).
\end{equation}
In \cite{Alcubierre:1998rq} the overall factor $\sqrt{4\pi}$ is explained 
as then $a_{00}$ is the average coordinate radius, $a_{10}$ is its average 
displacement in the z-direction and so on.
The shape of the apparent horizon is governed by the \emph{expansion}
\begin{equation}
  \label{apphorizonfunction} 
   H:= \nabla_i s^i + K_{ij}\,s^i s^j - K.
\end{equation}
Here $s^i$ is the (space-like) outward normal on this surface, $K_{ij}$ is the
extrinsic curvature and $K$ is its trace. 
The apparent horizon is defined by the requirement, that it is 
the outermost 2-surface with $H=0$ everywhere on that surface.
This ansatz confines the surface to be star-shaped.

This nonlinear elliptic equation is solved by the so called 'fast flow algorithm'.
Starting from a sphere that is definitely outside the horizon it flows
in pseudo time against the solution.

In this script the line numbers mean the location in the File \textsc{AHF.c}
in directory \textsc{/bam/src/projects/AHF/} as of about October 2007 with 
some changes in January 2008. This will at least give a rough estimate but
these numbers will change over time.

As an abbreviation for the simple partial derivative we use 
$\frac {\partial h} {\partial x^i} = \partial_i h$.

\subsection{Outline of the file AHF.c}
The following list will show an overview over the different parts
of the apparent horizon finder. The line numbers are not exact because
the file is edited occasionally. Use them as an estimate.
\begin{itemize}
  \item {Lines 1-187:} Declaration and allocation of variables.
  \item {Lines 188-320:} Computation of Legendre and spherical harmonics
    together with their derivatives. Store in variables e.g. 'P', 
    'dPtheta', 'dPdthetadtheta' and 'Y0', 'Yc','Ys', 'dYcdtheta', 
    'dYcdthetadtheta', 'dYcdthetadphi', 'dYsdphidphi'.
  \item {Lines 321-392:} Computation of the derivatives of the metric.
    Use first order finite differences in the Cartesian grid. Store in
    'dgxxdxg', 'dgxydxg', 'dgxzdxg', ... that are arrays for all (inner) points.
  \item {Lines 403-1211:} Main loop to find several horizons. Currently
   two horizons plus a common horizon can be found
  \begin{itemize}
    \item {Lines 412-451:} Guess center of initial surface from positions 
                           of punctures
    \item {Lines 467-482:} Guess radius of initial surface, from initial $Y_{lm}$
    \item {Lines 483-1207:} Loop that flows the surface towards the solution
    \begin{itemize}
      \item {Lines 503-525:} Compute height($\theta$,$\phi$) $\equiv$ radius 
                            of the surface from $Y_{lm}$
      \item {Lines 536-587:}  Compute derivatives of $x,y,z$ with respect to
        $\theta$ and $\phi$. Store as 'dxdt','dxdp','dydt','dydp','dzdt','dzdp'
      \item {Lines 589-945:} Loop over each point of the surface
      \begin{itemize}
        \item {Lines 597-602:} Compute radius($\theta$,$\phi$) of the surface 
                               from $Y_{lm}$
        \item {Lines 603-675:} Interpolate extrinsic curvature, 3-metric and 
            derivatives of 3-metric
        \item {Lines 676-720:} Compute derivatives of $r$, $\theta$ and $\phi$ 
          with respect to $x,y,z$ in local coordinate system
        \item {Lines 721-829:} Compute first and second derivatives of $F=r-h$
                  use the spherical harmonics and its derivatives
        \item {Lines 830-848:} Compute norm of $\nabla_a F$
        \item {Lines 848-872:} Compute $\nabla_a \nabla_b F$ and related objects
        \item {Lines 872-879:} Compute $H[i][j]$
        \item {Lines 880-898:} Compute $\sigma$ and $\rho$ and induced metric
        \item {Lines 899-898:} Flat space coordinate rotational killing vectors
                               and integrands of S
      \end{itemize}
      \item {Lines 953-1014:} Compute integrals over surface: 'Area', 'hrms',
                              'hmean', 'Sx', 'Sy', 'Sz'
      \item {Lines 1016-1032:} Calculate Mass and total Spin
      \item {Lines 1034-1125:} Print results
      \item {Lines 1128-1205:} Find spectral components
    \end{itemize}
  \end{itemize}
  \item {Lines 1212-1281} Free variables
\end{itemize}
%
%
\section{Detailed descriptions}
In this section the list presented above is explained in detail. The ordering
is strictly by the line numbering, but it is of course put in general context
whenever possible and has references to other parts of the program.

\subsection{The input of the program AHF}
The procedure AHF has the only parameter 'tL' that is a pointer to a 'level' 
structure. But within the code it relies on the functions Geti and Getd etc.
to receive input from within BAM. 

There are four static variables named
'search0', 'search1', 'search2' and 'find\_\-common'.
These four variables decide which horizons are searched for.
'find\_com\-mon' is initialized to zero, the rest is not set or altered, that
means on most compilers, that they are initialized to zero at the
first time the lines are executed (note: not every time the function
is called). The variables 'search\dots' are initialized in lines 116-118
but only within an if statement.

The implementation of these variables are cumbersome and error-prone.
On the long run this should be changed to a list of lists. In each list
the black holes would be listed that should be included within the 
specific search for a single or a common horizon. 

\subsection{Lines 1-187: Declaration and allocation of variables}
There are several hard coded values in the declaration list that should
be mentioned:
\begin{itemize}
  \item 'pi'=$\pi$ is computed from $\arccos(-1.0)$. But then it is not even used
         in lines 1028ff.
  \item 'xc'='yx'='zc'=0 (location of BH, is initialized for cases 
         'number'$\le$2 in lines 430ff, should be also initialized there 
         for clarity if 'number' $>$ 2).
  \item 'alpha'=1.0, 'beta'=0.5, from there 'A' and 'B' are computed. They are
        used to characterize the flow. Their declaration is not very visible.
        Is is better to have them near their (only) appearance in line 102.
  \item 'int1\_hrms' and 'int1\_hmean' are arrays of fixed size 100 
       (is this enough?)
          \warningsymbol NL 01/08 This should be changed. Theses two variables  
         are used like 'int1\_area' and should be dynamically allocated alike.
         Otherwise they will have problems for 'ntheta' $>$ 100, that is 
         quite likely.
  \item 'v\_l' and 'v' are fixed size arrays of size 6. This seems ok, they
        will store the six values 'area', 'hmean', 'hrms', 'Sx', 'Sy' and 'Sz' sucht that
        'bampi\_all\-reduce\-\_sum\_vector' can handle them efficiently.
  \item 'ext' is a char array of length 4. 'ext' will held (in line 1069) 
        one underscore and the number of the calculated horizon. 
        That will be enough if
        there are less than ten black holes (considering all the $2^n$
        different common horizons that might occur.)
  \item 'name' is a char constant with a fixed size of 201. It will held
        the complete output path where the horizon data is written. That 
        should be enough but a small condition in front of using it my help to find
        an error.
  \item 'LMAX1' is a \#defined variable (by the compiler). This seems unusual. Better have
        it within BAM via 'Geti()'.
  \item 'dequaleps' is a global variable. Here it is used to recognize a
        double value to be close to an integer value or not.   
\end{itemize}
The following variables are initialized by the bam functions 'Geti', 'Getd' and 'Gets':
'order', 'rank', 'ahf\_time', 'outdir', 'flow\_iter', 'pr', 'mass\_tol',
'hmean\_\-tol', 'nhorizons', 'ntheta', 'nphi', 'ahf\_common', 'ahf\_common\_time'.
The last two are directly used and not stored in a local variable.

In lines 93ff, the function returns if the time has not elapsed a multiple
of 'ahf\_time', that means the apparent horizon finder is not used every time step.

The number of horizons is fixed to at most 2 (from BHs) plus 1 (common horizon).
This is used in different places, most prominent at lines 108-122.

In lines 132-187 all allocations are made using dvector() or dmatrix()

We have a staggered grid in $\theta$- and $\phi$-direction 
(e.g. $\theta_i=d\theta(i+\frac 1 2) = \frac \pi {N_{\theta}} (i+\frac 1 2)$. 
Only the staggering in $\theta$-direction is 
needed to avoid the coordinate  singularity at $\theta=0$ and $\theta=\pi$. 
But the staggering in $\phi$-direction might be good for integration
(points definitely belong to one octant of the grid)
The formula for the locations of 'theta' and 'phi' is explicitly 
written in the code. This should be moved to some central place because
it will be repeated several times within the code! 
See lines 194, 508, 539, 592 and 1149.

\subsection{Lines 188-320: Computation of associated Legendre functions and 
    spherical harmonics and their derivatives}
The Legendre polynomials and than also the spherical harmonics can be 
efficiently computed at fixed positions using recursion relations. 
Since the spherical grid does not change it can be done once for the whole 
function.

The formulas that are written in the function AHF.c are those that are
mostly given in \cite{Gundlach:1997us}, equations (47)-(53). 
They are compared with 
those of 'http://math\-world.wolfram.com/\-LegendrePolynomial.html'
and (not quite done: ) in the book 'Numerical Reci\-pes in C++' \cite{Press:2002}.
\warningsymbol The normalization of the formulas don't agree with MathWorld. 
But it depends on
how they are used later in the integration (the normalization is different).

Note that $\sin(\theta)$ and $\cos(\theta)$ should/could be calculated
once for each point. The factor $1/\sqrt{4 \pi}$ can be calculated beforehand.
A list of the factorials should be computed once and stored,
since they are identically calculated in lines 207, 229 and 251. This would
also increase the readability of the code.

I will first give the formulas from Mathworld, they are called 
\emph{associated Legendre polynomials} and are further down on the page:
http://mathworld.\-wolfram.com/\-LegendrePolynomial.html, equations (60) and
following. With $x=\cos(\theta)$ and $u!!=u (u-2) (u-4)\cdots$ \;:
\begin{align}
  &\text{MathWorld:}\notag\\
  (l-m)P^m_l(x) &= x (2l-1) P^m_{l-1}(x) -(l+m-1) P^m_{l-2}(x)\\
  P^l_l(x) &= (-1)^l (2l-1)!!(1-x^2)^{l/2}\\
  P^l_{l+1}(x) &=x(2l+1) P^l_l(x) \\
  &\text{Gundlach:}\notag\\
  \bar P^m_l(x) &=\sqrt{\frac{2l+1}{l^2-m^2}}\Big(
    \sqrt{2l-1} x \bar P^m_{l-1}(x) 
    -\sqrt{\frac {(l-1)^2-m^2}{2l-3}} \bar P^m_{l-2}(x) \Big)\\
  \bar P^l_l(x)&=\frac 1 {\sqrt{4 \pi}} \frac {\sqrt{(2l+1)(2l)!}}{2^l l!}(1-x^2)^l\\
  &\text{AHF.c:}\notag\\  
  P[l][l] &= \frac 1 {\sqrt{4 \pi}} \sqrt{(2l+1) (2l)!}\frac 1 {2^l l!} 
             (-\sin\theta)^l, \quad l=0\dots LMAX1\\
  P[1][0] &= \sqrt{3} \cos\theta P[0][0] \quad \\
  P[l][m] &= \sqrt{\frac {2l+1} {l^2-m^2}} 
              \biggl(\sqrt{2l-1} \cos\theta\; P[l-1][m] \notag\\
          &\qquad \qquad  -\sqrt{\frac {(l-1)^2-m^2} {2l-3}} \;P[l-2][m]\biggr)
          , \notag\\ 
          &\qquad \qquad \quad l=0\dots LMAX1, m=0\dots l-1
\end{align}
The last equation from MathWorld is a special case of the first and should be used 
in the program as well, but it is not the case:
Realize that P[l][l-1] is (at first glance) not well defined because it
needs P[l-2][l-1] that is not calculate at all. But the prefactor for 
$m=l-1$ becomes zero anyway (This was changed NL/MTH 01/08).


Here is the table of the first polynomials and the ratios thereof. Use the 
abbreviations $N\coloneqq \frac 1 {\sqrt{4\pi}}$, $x \coloneqq \cos(\theta)$
and $y \coloneqq \sqrt{(1-x^2)} = \sin(\theta), \;0<\theta<\pi$.
A common rule could not yet be found NL 01/08.

\begin{center}
\begin{tabular}{c|llll}
  $P^m_l$ & AHF.c &  Mathworld  
      &$f=\frac {AHF.c}{Mathworld}$ &$f/N$\\ \hline
  $P^0_0$ & $N$				& $1$            & $N$             &$=\sqrt{1/1}$   \\
  $P^0_1$ & $N\sqrt{3} x$		& $x$            & $N\sqrt{3}$     &$=\sqrt{3/1}$   \\
  $P^1_1$ & $N(-\sqrt{6} y)/2$		& $-y $          & $N \sqrt{3/2}$  &$=\sqrt{3/2}$   \\
  $P^0_2$ & $N\sqrt{5}(3x^2-1)/2$	& $(3x^2-1)/2$   & $N \sqrt{5}$    &$=\sqrt{5/1}$   \\
  $P^1_2$ & $N(-\sqrt{30}x y)/2 $	& $-3x y $       & $N\sqrt{5/6}$   &$=\sqrt{5/6}$   \\
  $P^2_2$ & $N \sqrt{30} y^2 /4 $	& $ 3 y^2$       & $N\sqrt{5/6}/2$ &$=\sqrt{5/24}$  \\
  $P^0_3$ & $N \sqrt{7} x (5x^2-3)/2 $	& $x(5 x^2-3)/2$ & $N\sqrt{7}$     &$=\sqrt{7/1}$   \\
  $P^1_3$ & $N\sqrt{21}y(1-5x^2)/2 $	& $3y(1-5x^2)/2$ & $N\sqrt{7/3}/2$ &$=\sqrt{7/24}$  \\
  $P^2_3$ & $N \sqrt{210} x y/4 $	& $15 x y $      & $N\sqrt{7/5}/2$ &$=\sqrt{7/120}$ \\
  $P^3_3$ & $N (-\sqrt{35} y^3)/4$	& $-15y^3 $      & $N\sqrt{7/5}/12$&$=\sqrt{7/720}$ \\
  $P^m_l$ &                             &                & assume          &$=\sqrt{(2l+1)/?}$
\end{tabular}
\end{center}

There is simple common formula for the \textbf{derivatives of the Legendre 
Polynomials} (Mathworld equation (67) ):
\begin{align}
  \frac {d P^m_l(x)}{d\theta} &=\frac 1 {\sqrt{1-x^2}} \Big( 
    l x P^m_l(x) - (l+m) P^m_{l-1}(x)  \Big)
\end{align}
But this formula is not used! Within AHF.c the derivatives are
plain analytic derivatives of the corresponding formulas that are 
given above. Gundlach suggests this as well. This leads to the following 
formulas. The indices have the same range as above.
\begin{align}
  dPdtheta[l][l] &= \frac 1 {\sqrt{4 \pi}} \sqrt{(2l+1) (2l)!}\frac 1 {2^l l!} 
             (-\sin\theta)^l\\
  dPdtheta[1][0] &= \sqrt{3} (-\sin\theta P[0][0] 
                    +\cos\theta dPdtheta[0][0] )\\            
  dPdtheta[l][m] &= \sqrt{\frac {2l+1} {l^2-m^2}} 
              \biggl(\sqrt{2l-1} ((-\sin\theta)\; P[l-1][m] \notag\\
   &\qquad \qquad \qquad  +\cos\theta \; dPdtheta[l-1][m])\notag\\
   &\qquad \qquad -\sqrt{\frac {(l-1)^2-m^2} {2l-3}} \;dPdtheta[l-2][m]\biggr)\\
  dPdthetadtheta[l][l]&= \frac 1 {\sqrt{4 \pi}} \sqrt{(2l+1) (2l)!}
       \frac 1 {2^l l!} l \notag\\
  &\qquad \biggl((l-1) (-\sin\theta)^{l-2} (\cos\theta)^2
       +(-\sin\theta)^{l-1}\sin\theta)\biggr)\\
  dPdthetadtheta[1][0]&=\sqrt{3} \big(-\cos\theta P[0][0] 
    - 2 \sin\theta \;dPdtheta[0][0]\notag\\
    &\qquad \qquad  +\cos\theta \;dPdthetadtheta[0][0] \big)\\
  dPdthetadtheta[l][m]&=  \sqrt{\frac {2l+1} {l^2-m^2}}  
      \biggl(\sqrt{2l-1} \big(-cos\theta \; P[l-1][m] \notag\\
   &\qquad \qquad -2\sin(\theta) \; dPdtheta[l-1][m] \notag \\
   &\qquad \qquad +\cos(\theta) \; dPdthetadtheta[l-1][m] \big) \notag \\
   &\qquad \qquad -\sqrt{\frac {(l-1)^2-m^2} {2l-3}} \;dPdtheta[l-2][m]\biggr)
\end{align}

\paragraph{The Spherical Harmonics}
From Mathworld (http://mathworld.wolfram.com/\-SphericalHarmonic.html),
in equation (6) we get the definition of the spherical harmonics as
\begin{align}
  Y^m_l(\theta,\phi) = \sqrt{\frac {(2l+1)(l-m)!}{4 \pi (l+m)!}}
                    P^m_l(\cos \theta) e^{im\phi}.
\end{align}
Of course this can easily be split into the real and imaginary part via
\begin{equation}
  e^{i m \phi}=\cos (m \phi) + i \sin (m\phi)
\end{equation}
as in Mathworld equations (9) and (10) on that page.


This is also done in the paper by Gundlach and in the AHF.c. 
The spherical harmonics are here written as the sine and 
cosine part of the exponential representation i.e. $Y = Y_c + i Y_s$.
Moreover for $m=0$ the phase vanishes
and $Y_l^0$ will be real. In AHF.c the spherical harmonics are therefore
stored in the arrays 'Y0[0\dots LMAX1]', 'Yc[$l1$]' and 'Ys[$l1$]' where
$l1$ is a common index for both $l$ and $m$ as $l1=l (LMAX1+1)+m$.
Everywhere the index $l1$ covers the range $l=1\dots LMAX$, $m = [1 \dots l]$.
Actually the arrays that hold Y0, Yc and Ys are two-dimensional. The first index gives
the number within the grid in $\theta-$ and $\phi-$direction. But this index
is not written here, because the calculation is independent from the location
on the surface.
\begin{align}
  &\text{MathWorld:}\notag\\
  Y0^0_l &= P^0_l \\
  Yc^m_l &= \sqrt{2} P^m_l \cos (m\phi)\\
  Ys^m_l &= \sqrt{2} P^m_l \sin (m\phi)\\
  Y^{-m}_l &= (-1)^m Y^{*m}_l\quad 
    \text{here: * means complex conjugate}\\
  &\text{Gundlach:}\notag\\
  \bar Y^0_l &= \bar P^0_l(x)\\
  \bar Y^{|m|}_l  &= \sqrt{2} \bar P^{|m|}_l(x) \cos(m \phi)\\
  \bar Y^{-|m|}_l &= \sqrt{2} \bar P^{|m|}_l(x) \sin(m \phi)\\
  &\text{AHF.c:}\notag\\
  Y0[l] &=  P[l][0], \qquad l=0\dots LMAX1 \\
  Y\!c[l1]&= \sqrt{2} P[l][m] \cos(m\phi), \qquad l=1\dots LMAX1, m=1\dots l \\
  Y\!s[l1]&= \sqrt{2} P[l][m] \sin(m\phi)
\end{align}
The derivatives of the $Y^l_m$ are just the analytical expressions.
First derivatives of the spherical harmonics in AHF.c:
\begin{align}
  dY0dtheta[]] &= dPdtheta[l][0]\\
  dYcdtheta[l1]&=\sqrt{2} dPdtheta[l][m] \cos(m\phi)\notag \\
  dYsdtheta[l1]&=\sqrt{2} dPdtheta[l][m] \sin(m\phi)\\
  dYcdphi[l1]&=-\sqrt{2} P[l][m] m \sin(m\phi)\notag\\
  dYsdphi[l1]&= \sqrt{2} P[l][m] m \cos(m\phi)
\end{align}
Second derivatives:
\begin{align}
  dY0dthetadtheta[l]&=dPdthetadtheta[l][0]\\
  dYcdthetadtheta[l1]&= \sqrt{2} dPdthetadtheta[l][m] \cos (m\phi)\\
  dYcdthetadphi[l1]  &=-\sqrt{2} dPdtheta[l][m] m \sin (m\phi)\\  
  dYsdthetadtheta[l1]&= \sqrt{2} dPdthetadtheta[l][m] \sin (m\phi)\\
  dYsdthetadphi[l1]  &= \sqrt{2} dPdtheta[l][m] m \cos (m \phi)\\
  dYcdphidphi[l1]    &=-\sqrt{2} P[l][m] m^2 \cos (m \phi)\\
  dYsdphidphi[l1]    &=-\sqrt{2} P[l][m] m^2 \sin (m \phi)\\
\end{align}

\subsection{Lines 321-400: Derivatives of the metric}
The derivatives of the metric are calculated as simple second order
finite difference stencils. For example (with $idx=\frac 1 {2 \,dx}$, etc)
\begin{align}
  dgxxdxg[ijk] &= idx (gxxg[ijk+di] - gxxg[ijk-di])\\
  dgxydyg[ijk] &= idy (gxyg[ijk+dj] - gxyg[ijk-dj]).
\end{align}  
This is done for all inner points by the function 'forinnerpoints\_ijk(level)\{\}'.
Then the boundaries are set by the function 'set\_boundary\_symmetry(level, vl)'.
The neighbors of the 3D-grid index ijk are found by
adding 'di','dj','dk' for the respective direction.
These constants are not set within AHF.c but introduced within
'forinnerpoints\_ijk(level)\{\}'. 

\subsection{Lines 403-1211: Searching for several apparent horizons, surface initial guess}
The program as it is now (01/08) can only find up to three horizons, where
the third is a common one.
There are three variables search0, search1 and search2, that will independently
tell which horizon should be searched for (search\dots=1). Moreover there is the 
variable 'find\_common', 'common' and 'nhorizons'. 'nhorizons' is the maximal number of 
horizons to be searched for (the actual number may be less because of search\dots).
If 'find\_common' is set to 1, only this horizon will be searched for.
The variable 'common' is used when getting the initial guess for the center of a 
sphere and comes from the parameter file variable 'ahf\_common'.
In Lines 108-123 the number of horizons is clearly set to a maximum of 2.

The locations of the center of the surface is set to either the location of 
the puncture or to (0,0,0). The initial radius is half the minimum distance (only in x-direction) 
to the border of the innermost box [I guess the box will be
fairly symmetric around the puncture \warningsymbol but it might be problematic for 
the common horizon NL 01/08].
More precisely: $a0[0]=\sqrt{4 \pi} \;rmin\; /2$.

The surface is given by the expansion with spherical harmonics. For the
$m=0$ case the coefficients are in the array 'a0', otherwise in 'ac' and 'as' for the 
cosine and sine parts 'Yc' and 'Ys' of the expansion in spherical harmonics.

\subsection{The flow of the surface}
Within each iteration of the flow the radius is computed from the 
coefficients 'a0', 'ac' and 'as' as follows.
In the following calculations the indices are $i=[0\dots ntheta-1]$, 
$j=[0\dots nphi-1]$, the master index for the points is $i1=i \; nphi+j$ and 
$l=[0\dots LMAX1]$, $m=[1\dots l]$. [The calculation of a master index for 
the modes ($l1=l (LMAX+1) +m$) should be considered.]

rr has contributions from all l,m-modes, the first line is the scheme:
\begin{align}
  r &= \sum_{l=0}^{LMAX1} a_0 Y0^0_l +\sum_{l=1}^{LMAX1} \sum_{m=1}^{l} a_c Yc^m_l 
                                     +\sum_{l=1}^{LMAX1} \sum_{m=1}^{l} a_s Ys^m_l \\
  rr[i][j] &= \sum_{l} a0[l] Y0[i1][l]\notag \\ 
  &\quad+\sum_{m,l} Yc[i1][l (LMAX1+1)+m] \; ac[l][m] \notag \\
  &\quad + \sum_{m,l} Ys[i1][l (LMAX1+1)+m] \; as[l][m];
\end{align}
If at any of these points 'rr' gets larger than r\_max or below zero 
the program will stop the iteration.

Then the flow is calculated as change in the coefficients $a_{lm}$ 
see Alcubierre \cite{Alcubierre:1998rq} equation (10) and \cite{Gundlach:1997us}
equation (43) as
\begin{equation}
  a_{lm}^{(n+1)} = a_{lm}^{(n)} - \frac A {1 + Bl(l+1)} (\rho H)^{(n)}_{lm}.
\end{equation}
$(n)$ labels the iterations step, $\rho$ is some positive-definite (weight-)function
and $\rho H_{lm}$ are the Fourier components of the function $\rho H$.
Alcubierre et al. use
\begin{equation} 
  \rho = 2 r^2 |\nabla F| \Big[ ( g^{ij} -s^i s^j)(\bar g_{ij} 
         - \nabla_i r \nabla_j r)\Big]^{-1}
\end{equation} 
where $\bar g_{ij}$ is the flat background metric.
Both papers and the code compute values $A$ and $B$ from $\alpha$ and $\beta$ as
\begin{align}
  \label{defAB}
  A&= \frac {\alpha} {l_{max}(l_{max}+1)} + \beta, \qquad
   B= \frac {\beta} {\alpha}\\
 \text{with}\qquad \alpha &=1.0 \qquad \beta=0.5,
\end{align}
Gundlach reports the best results with these values.


\subsection{Lines 536-587: Compute derivatives of x,y,z in respect 
to $\theta$ and $\phi$}
The derivatives will be taken with respect to x,y,z but the 
spherical harmonics are in
$\theta$ and $\phi$ direction. There will be a transformation 
(r,$\theta$,$\phi$) $\rightarrow$ (x,y,z) by
\begin{align}
  x&=xc + r \sin \theta \cos \phi\\
  y&=yc + r \sin \theta \sin \phi\\
  z&=zc + r \cos \theta.
\end{align}
The derivatives of this transformation are also needed. Use the abbreviations
\begin{align}
  drdt &= (rtp1-rtm1)/(2 \;dtheta)\\
  drdp &= (rpp1-rpm1)/(2 \;dtheta)
\end{align}
where rtp1, rtm1, rpp1, rpm1 are the values of rr one step in the direction of $\theta$ and $\phi$
respectively. Then it is calculated
\begin{align}
  dxdt[i1] &= (drdt*\sin\theta + rr[i][j]*\cos\theta)*\cos\phi \\
  dydt[i1] &= (drdt*\sin\theta + rr[i][j]*\cos\theta)*\sin\phi \\
  dzdt[i1] &=  drdt*\cos\theta - rr[i][j]*\sin\theta \\
  dxdp[i1] &= (drdp*\cos\phi   - rr[i][j]*\sin\phi)*\sin\theta \\
  dydp[i1] &= (drdp*\sin\phi   + rr[i][j]*\cos\phi)*\sin\theta \\
  dzdp[i1] &=  drdp*\cos\theta.
\end{align}
That means that the derivative with respect to r is done with a 
second order finite differencing stencil. The $\theta$- and 
$\phi$-derivatives are found analytically.


\subsection{Lines 603-675: Interpolation of extrinsic curvature, 
3-metric and derivatives}
The Interpolation of the extrinsic curvature, the 3-metric and the
derivatives of the 3-metric over the surface are done by the 
external procedure (external to AHF.c)
'interpolate\_xyz\_local\_minimal\_withsym'.
The interpolation is restricted to points in this processor. If this is 
not the case the array 'localp[i1]' for this point is set to -1.

The inverse $g^{ij}$ of $g_{ij}$ is calculated analytically. First the
sub-determinants of $g_{ij}$ are calculated i.e. 'ginvdetxx', 
'ginvdetxy' etc. then the determinant and then the inverse elements:
\begin{align}
  ginvdetxx &= gyy \;gzz - gyz gyz \\
  ginvdetxy &= gxz \;gyz - gxy gzz \qquad etc.\\
  detg &= gxx \; ginvdetxx + gxy \; ginvdetxyg + xz \; ginvdetxz\\
  ginvxx&=ginvdetxx/detg\\
  ginvxy&=ginvdetxy/detg \qquad etc.
\end{align}
The naming 'ginvdetxx' seems odd to me, since it is not the inverse
metric yet (NL 01/08).

The trace of the extrinsic curvature is
\begin{align}
  K&= g^{ij} K_{ij}\\
   &=    ginvxx\;Kxx + ginvxy\;Kxy + ginvxz\;Kxz \notag\\
   &\;  +ginvyx\;Kxy + ginvyy\;Kyy + ginvyz\;Kyz \notag\\
   &\;  +ginvzx\;Kxz + ginvzy\;Kyz + ginvzz\;Kzz
\end{align}

Since the following calculation uses a special central point for the 
spherical grid, the Cartesian coordinates are relocated (by translation),
those variables are marked with a 'p':
\begin{align}
  xp &= x-xc \\
  yp &= y-yc \\
  zp &= z-zc \\
  rp &= \sqrt{xp^2 + yp^2 +zp^2}\\
  rhop &= \sqrt{xp^2 + yp^2}.
\end{align}

\subsection{Lines 676-720: Derivatives of $r$,$\theta$ and $\phi$ with 
respect to x,y,z}
Also the transformation  (x,y,z) $\rightarrow$ ($r$, $\theta$,$\phi$) is 
needed when calculating
the induced metric on the surface. Here the transformation looks like
\begin{align}
  r&=\sqrt{x^2+y^2+z^2}\\
  \theta&=\arctan \frac {\sqrt {x^2+y^2}} z  \quad(= \arctan \frac \rho z)\\
  \phi&=\arctan \frac y x\quad.
\end{align}
Remember that here the shifted coordinates $xp, yp, zp, rp$ and $rhop$
are used. The first derivatives are
\begin{align}
  drdx &= xp/rp  \notag\\
  drdy &= yp/rp  \notag\\
  drdz &= zp/rp  \\
  dthetadx &= zp\; xp/(rp^2 rhop)  \notag\\
  dthetady &= zp\; yp/(rp^2 rhop)  \notag\\
  dthetadz &= -rhop/(rp^2)       \\
  dphidx &= -yp/(rhop^2)   \notag\\
  dphidy &= xp/(rhop^2)    \notag\\
  dphidz &= 0 .
\end{align}
Note on performance: The second derivatives are symmetric, that
can save some calculations.
The second derivatives with respect to (x,y,z) are
\begin{align}
  drdxdx &= 1/rp - xp^2/(rp^3) \notag\\
  drdxdy &= - xp \;yp/(rp^3)      \notag\\
  drdxdz &= - xp \;zp/(rp^3)      \\
  drdydy &= 1/rp - yp^2/(rp^3) \notag\\
  drdydz &= - yp \;zp/(rp^3)      \notag\\
  drdzdz &= 1/rp - zp zp/(rp^3)
\end{align}
\begin{align}
  dthetadxdx &= zp \frac{-2 xp^4-xp^2 yp^2+yp^4+zp^2 yp^2} {rp^4 rhop^3} \notag\\
  dthetadxdy &= - \frac{xp\; yp\; zp (3 xp^2+3 yp^2+zp^2)}{ rp^4 rhop^3}     \notag\\
  dthetadxdz &= \frac {xp (xp^2+yp^2-zp^2)} {rp^4 rhop}               \\
  dthetadydy &= \frac {zp (-2 yp^4-yp^2 xp^2+xp^4+zp^2 xp^2)} {rp^4 rhop^3}  \notag\\
  dthetadydz &= \frac {yp (xp^2+yp^2-zp^2)}{rp^4 rhop}                       \notag\\
  dthetadzdz &= 2 zp\; rhop/(rp^4)
\end{align}
\begin{align}
  dphidxdx &= 2 yp \;xp/(rhop^4)           \notag\\
  dphidxdy &= \frac {yp^2-xp^2} {rhop^4} \notag\\
  dphidxdz &= 0                          \\
  dphidydy &= - \frac {2 yp\; xp}{rhop^4}  \notag\\
  dphidydz &= 0                          \notag\\
  dphidzdz &= 0.
\end{align}
The above formulas seem to agree with Mathematica calculated ones.

\subsection{Lines 721-825: The Calculation of the horizon function 
            with F and its derivatives}
The level set function is $F=r-h$, where $h=\sum_{lm} a_{lm} Y_l^m$ is the 
height function. We need the covariant derivative $\nabla_i F$ and its 
derivatives in Cartesian coordinates. With $X \in (x,y,z)$ the first derivatives
will have the form
\begin{align}
  \partial_X F &= \frac {\partial r}{\partial X}
       - \sum_{l,m} a_{lm} \Big( \frac {\partial \theta} {\partial X}
                                 \frac {\partial Y_l^m} {\partial \theta}
                              +  \frac {\partial \phi}  {\partial X}
                                 \frac {\partial Y_l^m} {\partial \phi}
                               \Big)\\
     &= \frac {\partial r}{\partial X} 
       -\sum_{l} a0_{l} \Big( \frac {\partial \theta} {\partial X}
                                 \frac {\partial Y0_l^0} {\partial \theta}
                               \Big)\notag\\
     &\qquad - \sum_{l,m} ac_{lm} \Big( \frac {\partial \theta} {\partial X}
                                 \frac {\partial Yc_l^m} {\partial \theta}
                              +  \frac {\partial \phi}  {\partial X}
                                 \frac {\partial Yc_l^m} {\partial \phi}
                               \Big)\notag \\
     &\qquad - \sum_{l,m} as_{lm} \Big( \frac {\partial \theta} {\partial X}
                                 \frac {\partial Ys_l^m} {\partial \theta}
                              +  \frac {\partial \phi}  {\partial X}
                                 \frac {\partial Ys_l^m} {\partial \phi}
                               \Big).
\end{align}
Note the split of $Y_l^m$ into the different
variables $Y0_l$, $Yc_l^m$ and $Ys_l^m$. 
Note also that $Y0_l$ has no dependence from $\phi$.

In the following table the index of the location within the surface grid
[i1] is not shown because on every point of the surface the calculation
is the same. The \textbf{first derivatives of F} as they are in the 
program AHF.c are
\begin{align}
  \partial_x F &= drdx -\sum_{l=0}^{LMAX1} a0[l]\;dthetadx\; dY0dtheta[l]\notag\\
       &\qquad         -\sum_{l=1}^{LMAX1} \sum_{m=1}^{l}  ac[l][m] 
                           \Big( dthetadx\; dYcdtheta[l1] 
                                  +dphidx \;dYcdphi[l1] \Big)\notag\\
       &\qquad         -\sum_{l=1}^{LMAX1} \sum_{m=1}^{l}  as[l][m] 
                           \Big( dthetadx\; dYsdtheta[l1] 
                                  +dphidx\; dYsdphi[l1] \Big)
\end{align}
\begin{align}                           
  \partial_y F &= drdy -\sum_{l=0}^{LMAX1} a0[l]\;dthetady\; dY0dtheta[l]\notag\\
       &\qquad         -\sum_{l=1}^{LMAX1} \sum_{m=1}^{l}  ac[l][m] 
                           \Big( dthetady\; dYcdtheta[l1] 
                                  +dphidy \;dYcdphi[l1] \Big)\notag\\
       &\qquad         -\sum_{l=1}^{LMAX1} \sum_{m=1}^{l}  as[l][m] 
                           \Big( dthetady\; dYsdtheta[l1] 
                                  +dphidy\; dYsdphi[l1] \Big)
\end{align}
\begin{align}                                  
  \partial_z F &= drdz -\sum_{l=0}^{LMAX1} a0[l]\;dthetadz\; dY0dtheta[l]\notag\\
       &\qquad         -\sum_{l=1}^{LMAX1} \sum_{m=1}^{l}  ac[l][m] 
                           \Big( dthetadz\; dYcdtheta[l1] 
                                  +dphidz \;dYcdphi[l1] \Big)\notag\\
       &\qquad         -\sum_{l=1}^{LMAX1} \sum_{m=1}^{l}  as[l][m] 
                           \Big( dthetadz\; dYsdtheta[l1] 
                                  +dphidz\; dYsdphi[l1] \Big)
\end{align}


For the \textbf{second derivatives of F} not in a complete list 
of formulas in the program are given but only the 
scheme. Note that $Y0_l$ has no dependence from $\phi$. With
$X,Y \in (x,y,z)$ it is
\begin{align}
  \partial_X \partial_Y F &= \frac {\partial r}{\partial X \partial Y} \notag\\
  &\quad -\sum_{l=0}^{LMAX1} a0[l] 
      \Big( \frac {\partial \theta}{\partial X \partial Y}
            \frac {\partial Y0_l^m} {\partial \theta}
           +\frac {\partial \theta} {\partial X }
            \frac {\partial \theta} {\partial Y }
            \frac {\partial Y0_l^m} {\partial \theta \partial \theta} \Big) \notag \\
  &\quad -\sum_{l=0}^{LMAX1}\sum_{m=1}^{l} ac[l][m] 
      \Big( \frac {\partial \theta}{\partial X \partial Y}
            \frac {\partial Yc_l^m} {\partial \theta}
           +\frac {\partial \theta} {\partial X}
              \big(\frac {\partial \theta} {\partial Y}
                    \frac {\partial Yc_l^m} {\partial \theta \partial \theta}
                   +\frac {\partial \phi} {\partial Y}
                    \frac {\partial Yc_l^m} {\partial \theta \partial \phi} \big)
                    \notag\\
  &\qquad \qquad \qquad \qquad
           +\frac {\partial \phi}  {\partial X \partial Y}
            \frac {\partial Yc_l^m} {\partial \phi}  
           +\frac {\partial \phi}  {\partial X}
           \big(\frac {\partial \theta}  {\partial Y}
                \frac {\partial Yc_l^m} {\partial \theta \partial \phi}
               +\frac {\partial \phi}  {\partial Y}
                \frac {\partial Yc_l^m} {\partial \phi \partial \phi} \big)
      \Big) \notag \\
  &\quad -\sum_{l=0}^{LMAX1}\sum_{m=1}^{l} as[l][m] 
      \Big( \frac {\partial \theta}{\partial X \partial Y}
            \frac {\partial Ys_l^m} {\partial \theta}
           +\frac {\partial \theta} {\partial X}
              \big(\frac {\partial \theta} {\partial Y}
                    \frac {\partial Ys_l^m} {\partial \theta \partial \theta}
                   +\frac {\partial \phi} {\partial Y}
                    \frac {\partial Ys_l^m} {\partial \theta \partial \phi} \big)
                    \notag\\
  &\qquad \qquad \qquad \qquad
           +\frac {\partial \phi}  {\partial X \partial Y}
            \frac {\partial Ys_l^m} {\partial \phi}  
           +\frac {\partial \phi}  {\partial X}
           \big(\frac {\partial \theta}  {\partial Y}
                \frac {\partial Ys_l^m} {\partial \theta \partial \phi}
               +\frac {\partial \phi}  {\partial Y}
                \frac {\partial Ys_l^m} {\partial \phi \partial \phi} \big)
      \Big)
\end{align} 


\paragraph{Further calculations with $F$:}
The derivatives of F with upper index are found by
\begin{equation}
  \partial^X F = g^{XY} \partial_Y F.
\end{equation}
The norm of $\nabla_X F$ is 
\begin{equation}
  u[i][j]=|\nabla F | = \sqrt{ \partial^x F \partial_x F
                              +\partial^y F \partial_y F
                              +\partial^z F \partial_z F}.
\end{equation}
Note that $\nabla_X F =\partial_X F$. 
\warningsymbol Here is a condition that might give incorrect results: If the sum inside of 
the root is negative the whole root is taken to be zero and the flag 'u0'
is set to 1. The final value of the apparent horizon function at this 
position is only evaluated if u0=0.
I guess it is a way to protect against floating point errors. But does
it happen often? At least it should be printed out a warning NL 01/08.

The \textbf{computation of $\nabla_a \nabla_b F$} is done with the following
formulas, the symmetries of the metric are used explicitly. From
\begin{align}
  \nabla_a \nabla_b F &= \partial_a \partial_b F - \Gamma^k_{ab} \nabla_k F\\
 \text{and}\qquad \qquad
  \Gamma^k_{ab} &= \frac 1 2 g^{mk}(\partial_a g_{bm} +\partial_b g_{am} - \partial_m g_{ab})\\
 \text{it follows}\qquad
  \nabla_a \nabla_b F &= \partial_a \partial_b F - \frac 1 2 \partial^m F
    (\partial_a g_{bm} +\partial_b g_{am} - \partial_m g_{ab})
\end{align}
\begin{align}
  \nabla_x \nabla_x F &=\partial_x \partial_x F - \frac 1 2
    \Big( \partial^x F \partial_x g_{xx} 
        + \partial^y F(2 \partial_x g_{xy} - \partial_y g_{xx})
        + \partial^z F(2 \partial_x g_{xz} - \partial_z g_{xx}) \Big)\\
  \nabla_x \nabla_y F &=\partial_x \partial_y F - \frac 1 2
    \Big( \partial^x F \partial_y g_{xx} 
        + \partial^y F \partial_x g_{yy}
        + \partial^z F(\partial_x g_{yz} +\partial_y g_{xz} - \partial_z g_{xy}) \Big)\\
  \nabla_x \nabla_z F &=\partial_x \partial_z F - \frac 1 2
    \Big( \partial^x F \partial_z g_{xx} 
        + \partial^y F (\partial_x g_{yz} +\partial_z g_{xy} - \partial_y g_{xz})
        + \partial^z F  \partial_x g_{zz} \Big)\\
  \nabla_y \nabla_y F &=\partial_y \partial_y F - \frac 1 2
    \Big( \partial^y F \partial_y g_{yy} 
        + \partial^x F (2 \partial_y g_{xy}- \partial_x g_{yy})
        + \partial^z F (2 \partial_y g_{yz} -\partial_z g_{yy}) \Big)\\
  \nabla_y \nabla_z F &=\partial_y \partial_z F - \frac 1 2
    \Big( \partial^y F \partial_z g_{yy} 
        + \partial^x F (\partial_y g_{xz}+\partial_z g_{xy} - \partial_x g_{yz})
        + \partial^z F \partial_y g_{zz} \Big)\\
  \nabla_z \nabla_z F &=\partial_z \partial_z F - \frac 1 2
    \Big( \partial^z F \partial_z g_{zz} 
        + \partial^x F (2 \partial_z g_{xz} - \partial_x g_{zz})
        + \partial^y F (2 \partial_z g_{yz} - \partial_y g_{zz}) \Big)
\end{align}
Within the program $\nabla_i \nabla_j F$ is written as 'nnFij', with $i,j \in (x,y,z)$.

The contracted second covariant derivative of $F$ is
\begin{align}
  d2F &=g^{ab} \nabla_a \nabla_b F \\
      &=ginvxx \;nnFxx + ginvxy \;nnFxy + ginvxz \;nnFxz \notag\\
      &\;\;+ ginvyx \;nnFxy + ginvyy \;nnFyy + ginvyz \;nnFyz\notag\\
      &\;\;+ ginvzx \;nnFxz + ginvzy \;nnFyz + ginvzz \;nnFzz.
\end{align}                    
The contraction of two $\partial^a F$ with $K_{ab}$ is called 'dFdadFdbKab':
\begin{align}
  dFdadFdbKab&=\partial^a F \partial^b F K_{ab}\\
     &=dFupdx\;dFupdx\;Kxx + 2\;dFupdx\;dFupdy\;Kxy \notag\\
     &\quad + 2\;dFupdx\;dFupdz\;Kxz + dFupdy\;dFupdy\;Kyy \notag\\
     &\quad + 2\;dFupdy\;dFupdz\;Kyz + dFupdz\;dFupdz\;Kzz.
\end{align}
The contraction of two $\partial^a F$ with $\nabla_a \nabla_b F$ is called 'dFdadFdbdFdadb':
\begin{align}
  dFdadFdbdFdadb&=\partial^a F \partial^b \nabla_a \nabla_b F\\
    &=dFupdx\;dFupdx\;nnFxx + 2\;dFupdx\;dFupdy\;nnFxy\notag\\
    &\quad+ 2\;dFupdx\;dFupdz\;nnFxz + dFupdy\;dFupdy\;nnFyy \notag\\
    &\quad+ 2\;dFupdy\;dFupdz\;nnFyz + dFupdz\;dFupdz\;nnFzz  
\end{align}

\paragraph{The expansion, the weight function and the induced metric}
Finally the expansion at point (i,j) is computed:
\begin{align}
  H &= g^{ab} \nabla_a \nabla_b F |\nabla F|^{-1} 
         + \partial^a F \partial^b F K_{ab} |\nabla F|^{-2}
         - \partial^a F \partial^b \nabla_a \nabla_b F |\nabla F|^{-3} -K\\
  H[i][j] &=  \frac {d2F}{u[i][j]} + \frac {dFdadFdbKab}{u[i][j]^2}
       -\frac {dFdadFdbFdadb}{u[i][j]^3} - K       
\end{align}

Then the \textbf{weight function $\rho$} is computed.
The program uses the variable 'sigma' that is set to be 1 
everywhere. It might be a remnant of the Gundlach version (after equation (43),
where he states that the weight function of the flow method can be $\rho= |\nabla F| \sigma$, 
actually $\sigma$ is never been used independently. 
Within his algorithm only $\rho$ is needed. Later AHF.c uses 
\begin{equation}
  \label{weightrho}
  rho[i][j] = H[i][j] \;u[i][j]\; sigma[i][j],
\end{equation}
for the flow of the spectral coefficients. 

The induced metric $h_{ab}$ on the horizon, here $a,b \in (\theta,\phi)$ and
i,j $\in$ (x,y,z). 
\begin{align}
  h_{ab} &= \frac {\partial i} {\partial a} 
           \frac {\partial j} {\partial b} g_{ij} \quad \text {e.g.}\\
  h_{11} & =\; dxdt[i1]\;(dxdt[i1]\;gxx+dydt[i1]\;gxy+dzdt[i1]\;gxz) \notag\\
   &\quad   +dydt[i1]\;(dxdt[i1]\;gxy+dydt[i1]\;gyy+dzdt[i1]\;gyz) \notag\\
   &\quad   +dzdt[i1]\;(dxdt[i1]\;gxz+dydt[i1]\;gyz+dzdt[i1]\;gzz) \\
  deth &= h11\; h22 - h12 \; h12 
\end{align}


The normal vector on the surface is 
\begin{align}
  R^i&=g^{ij}\nabla_j F/ |\nabla F|= \partial^i F / |\nabla F| \\
  Rx &= dFupdx/u[i][j]\\
  Ry &= dFupdy/u[i][j]\\
  Rz &= dFupdz/u[i][j]
\end{align}
This could have been calculated before and used in the calculation of $H$.


\subsection{The killing vectors}   
The flat space coordinate rotational killing vectors are computed.
Note that actually the differences of the coordinates are already known and computed 
($zp=z-zc$ etc.) but not used here. $phi_{(i)}$ are the killing vectors
\begin{align}
  & & \phi_{(x)} &= (0, -z, y)\\
  & & \phi_{(y)} &= (z, 0, -x)\\
  & & \phi_{(z)} &= (-y, x, 0)\\
   phix\_x &=  0     & \quad phix\_y &= -(z-zc) &\quad phix\_z &=  (y-yc) \\
   phiy\_x &= (z-zc) & \quad phiy\_y &=  0      &\quad phiy\_z &= -(x-xc) \\
   phiz\_x &= -(y-yc)& \quad phiz\_y &=  (x-xc) &\quad phiz\_z &=  0
\end{align}
\warningsymbol In Dreyer et al \cite{Dreyer:2002mx} equation (35) the Killing vector 
(there called $\xi$) for a two-sphere obeys the relation 
\begin{align}
  \frac {d\theta}{dt} &= \xi^{\theta}(\theta,\phi)\\
  \frac {d\phi}  {dt} &= \xi^{\phi}  (\theta,\phi),
\end{align}
but this does not seem the source of the formula above. In their equation (32) and (34)
other definitions are given.

\subsection{The integrals over the surface (lines 950ff)}
It follows the calculation of the integrands of spin and mass, for each point.
The subscript $(k)$ is one of the resulting indices for the spin vector.
$R^a$ is the normal to the surface.
\begin{align}
  &\text{Dreyer et al eq. (25):}\\
  J &= \frac 1 {8\pi} \oint_S (\phi^a R^b K_{ab}) d^2 V\\
  &\text{AHF.c (integrand) scheme:}\\
  I_{(k)}^i &= \sqrt{\det h}\;(\phi_{(k)}^i R^j K_{ij})\\
  &\text{AHF.c (integrand):}\\
  intSx[i][j] &=\sqrt{deth[i][j]} \;\big(
            phix_x\;Rx\;Kxx + phix_x\;Ry\;Kxy + phix_x\;Rz\;Kxz \notag\\
  &\quad  + phix_y\;Rx\;Kxy + phix_y\;Ry\;Kyy + phix_y\;Rz\;Kyz \notag\\
  &\quad  + phix_z\;Rx\;Kxz + phix_z\;Ry\;Kyz + phix_z\;Rz\;Kzz \big) \\
  intSy[i][j] &= \text{etc.}
\end{align}

These calculations are done for all points in a parallel way. In the array
'globalp' is stored by which processor the point was calculated.

The program calculates 6 integrals over the surface: The area 'area', the
root mean square of h 'hrms', the mean value of h 'hmean' and the
three components of the spin 'Sx','Sy' and 'Sz'.
These values are calculated from integrals (sums) over all points
of the surface. First the integral is taken along the $\phi-$direction
then along the $\theta$-direction. $h_{ab}$ is the 2-metric on the surface and
$R^j$ is the normal on the surface.
\begin{align}
  area &=    \iint d\phi d\theta \sqrt{\det h}  \\
  h_{rms} &= \iint d\phi d\theta \;H^2 \sqrt{\det h}  \\
  h_{mean} &=\iint d\phi d\theta \;H \sqrt{\det h} \\
  S_{(x)} &= \iint d\phi d\theta \;(\phi_{(k)}^i R^j K_{ij}) \sqrt{\det h} \\
  S_{(y)} &= \iint d\phi d\theta \;(\phi_{(k)}^i R^j K_{ij}) \sqrt{\det h} \\
  S_{(z)} &= \iint d\phi d\theta \;(\phi_{(k)}^i R^j K_{ij}) \sqrt{\det h}
\end{align}
'h\_rms' is later divided by 'area'. The components of $S$ are divided by $8 \pi$
(see below).
These values are stored in this order in the array 'v\_l' in each processor
and than added up to give the overall values of 'area', 'hmean', 'hrms', 
'Sx', 'Sy', 'Sz'. These are stored in \textbf{this} order ('hmean' before 
'hrms') also in the array v.
Note that 'dphi' and 'dtheta' could/should stand outside of the loop.

The \textbf{mass} and some kind of radius (from the $a_{00}$ component)
are calculated as 
\begin{align}
  mass &=  \sqrt{\frac {area}{16 \pi}} \\
  radius &= a0[0]/\sqrt{4\pi}.
\end{align}
At the start of each iteration over the search for one horizon, the coefficient
is/was calculated reverse from this: $a0[0] = \sqrt{4 \pi}\;\; r\_init$.

The other values (but not within the array 'v') are then rescaled,
where the definition $\pi=\arccos (-1)$ is used.
\begin{align}
  hrms &= hrms /area \\
  Sx &= Sx / (8 \pi ) \\
  Sy &= Sy / (8 \pi ) \\
  Sz &= Sz / (8 \pi ) \\
  S &= \sqrt{S\!x^2 + S\!y^2 +S\!z^2}
\end{align}

\subsection{Algorithm stops and Output}
The horizon finder AHF can print several characteristics as of 01/08.
If the general variable 'ahf\_verbose' is not 'no' than the variable
'pr' is set. The main output is only done if 'pr' is set. Most error
messages though are written directly.

Since the program can in principle run in parallel, the main output
is only done from the 'rank=0' processor. But the intermediate steps
(within the loop over all points) write the output directly.
 
The output in each iteration in pseudo time are
$mass$, $radius=a0[0]/\sqrt{4 \pi}$, $hrms$ and $hmean$ and the spin $S$.

The algorithm assumes the horizon to be found, if the difference in mass
during consecutive steps in pseudo time is less than some tolerance, or
$|mass - mass_{old}| < mass_{tol}$.
Note that it might also possible to give a tolerance on 'hmean' or 'hrms'.
On the other hand the finder fails if the absolute value of 'hmean' surpasses
some threshold ('hmean\_tol') or if it has done a certain amount of iterations
('flow\_iter').
\warningsymbol The mass seems not to be a perfect indicator of the horizon's
progress in pseudo time. Maybe a mixture of two of the above criteria would
be more stable.

If a horizon is found the following values are written to screen:
'mass', 'radius', 'hrms', 'hmean', 'Sx', 'Sy', 'Sz', 'S'.
Then it prints values to file:
'time', 'xc', 'yc', 'zc', 'mass', 'Sx', 'Sy', 'Sz' and 'S'.
Note that the condition ('rank=0') is double checked in line 1062.
\warningsymbol And notice that the shifted positions 'xc' etc. are used instead
the overall values 'x', 'y', 'z'.
Each horizon is put into a separate directory. Each time into the same
file (that's why it is written there).

If the variable 'ahf\_output' is set to 'yes' than a procedure
AHF\_ouput is called that also writes 
'ntheta', 'dtheta', 'nphi', 'dphi', 'xc', 'yc', 'zc', 'rr', 'number', 
'time', 'ahf\_time'.

\subsection{Lines 1123-1200: Flow of spectral coefficients}
The surface is determined by the coefficients 'a0', 'ac' and
'as' of the expansion in spherical harmonics. To advance them during
the flow, they are changed to new values.

Some intermediate values are calculated and stored in the 
arrays 'spec0\_l[l]', 'spec\_cl[ml]' and 'spec\_sl[ml]', where
$l = 0 \dots LMAX1$ and 'lm' is a joint index for $l=1 \dots LMAX1$ and
$m=0\dots l$.

\warningsymbol NL 01/08 I think the loop for $m$ has to start at $m=1$ since
the $m=0$ is covered in the loop for 'spec0\_l'. That might be now problem
if all values at $m=0$ are initialized to zero.

The values are integrals over the surface:
\begin{align}
  spec0  &= \iint d\theta d\phi \sin\theta \;\rho \;Y0\\
  spec\_c&= \iint d\theta d\phi \sin\theta \;\rho \;Y\!c\\
  spec\_s&= \iint d\theta d\phi \sin\theta \;\rho \;Y\!s
\end{align}
with the weight $\rho$ from equation \eqref{weightrho}.

Using these values the new spectral coefficients are calculated 
by a certain change from the previous ones:
\begin{align}
  a0[l]    &= a0[l]\quad\;-\frac {A}{1+B \;l (l+1)} \;spec0[l] \\
  ac[l][m] &= ac[l][m]    -\frac {A}{1+B \;l (l+1)} \;spec\_c[l1] \\
  as[l][m] &= as[l][m]    -\frac {A}{1+B \;l (l+1)} \;spec\_s[l1].
\end{align}
$A$ and $B$ are given in equation \eqref{defAB}.
\warningsymbol Again the loops don't seem to fit: the [l][m] values are
starting with $l=0$ but that is only needed for a0[0], ac[0][0] has no meaning.


\subsection{Lines 1212-1274: Deallocations}
During the deallocations of the arrays the
function 'interpolate\_setorder( )' with argument 'Geti("order\_RP")' is used.
This seems strange, because after that nothing more happens.
I don't know what this function does NL 01/08.

%
%
\newpage 
\subsection{General issues}
Is it really necessary to write 1.0/2.0 instead of 0.5?

In line 343 the array 'vl' is stored by 'vlpush' under 
the name "ahf\_dgdxxx". That seems to be a strange name \dots

In lines 1041ff is a print statement that seems to be done
by all processors (no 'if (rank==0)'). 

Some lines further down there is the 'if (rank==0)' statement twice,
one inside the other. That is needless.

At Line 207, the loop runs from $ l= 0\dots  LMAX$ and within the loop
it tests for $l>0$. Better calculate P[0][0] before (outside of) the loop.


'LMAX1' is \#defined in the beginning. It might be better to make
it a const variable or even better to give it from the program via 'Geti()'.

The variable 'dtime' in line 93 is an integer and has an 
implicit conversion to integer from double. This is shadowing the intent
of this variable.


At line 987 the program checks whether the point was done
by any processor, and then it computes some values, otherwise it will 
make the program fail. That might be done separately not within this loop
to make the logic of the program more clear. This test is
repeated in line 1157 when calculating the spectral components.



\subsection{Performance issues}
Here is a list of things that will (or might) improve the
horizon finder's performance.
\begin{itemize}
 \item Compute the factorial beforehand and store it in an array, that will also
       be more easy to read.
 \item Compute $\sin(\theta)$, $\cos(\theta)$ and maybe other trigonometric 
     functions once for all points and  store them (lines 576-586).
 \item The factor 1/sqrt(4 pi) can be calculated beforehand while computing
       the Lagrange polynomial.
 \item The derivatives of P[l][0] can be computed much simpler because
        P[0][0] is known (and it is a constant) (lines $\approx$ 200-300) 
 \item line 576: the check whether nphi is odd can be done in the beginning,
       or at least outside of the loop.
 \item Lines 704ff: Second derivatives are symmetric, can re-use calculated
       values
 \item Line 842ff. The sum is checked to be greater or equal to zero 
       because it is exactly the term
       inside a square root, but there it is written again.
 \item The integrals over the sphere can be simplified because 'dphi' and 
       'dtheta' are constant at all points. Do their multiplication 
       outside of the loops.
\end{itemize} 


\bibliographystyle{mybib}
\bibliography{AHF}

\end{document}

