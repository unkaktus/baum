(*******************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which
typically will have the same name as this file except ending in
".nb" instead of ".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent
to using the Evaluate Initialization Cells menu command in the front
end.

DO NOT EDIT THIS FILE.  This entire file is regenerated
automatically each time the parent Notebook file is saved in the
Mathematica front end.  Any changes you make to this file will be
overwritten.
***********************************************************************)













































BeginPackage["sym`"];
(* Reserve Keywords *)

{INV,SQR,CUB,QAD,exp,pow};

{Radius,GridDim,DX,DY,XMin,XMax,YMin,YMax,Grid,Times,TimeSeries};

{LinearMomentum,AngularMomentum,MADM,MADMB};

{RePsi4,ImPsi4,AbsPsi4};

{Position,Speed};

{Lapse, Shift};


{aKerr, RealFreq, ImagFreq};
EndPackage[];















BeginPackage[
    "SphereData`",{"sym`","MapLookup`","Statistics`DataManipulation`"}];



ReadSphereData::usage="ReadSphereData[file] reads a file in BAM SphereData format.";\


TimeSeriesToSphereData::usage="TimeSeriesToSphereData[data1D, modFunction] constructs BAM SphereData from a time series and a 2D array.";\


ReadTimeSeriesData::usage="ReadTimeSeriesData[file] reads ascii 1D data in x y column format from a file.";\


Qualify0DData::usage="Qualify0DData[data0D_,data2D_] defines adds meta-data to a 0d time series from a 2D time series."
\

GridSlice::usage="GridSlice[timeSeries_,k_] extracts the k-th time slice from 2D time series data."
\

FlattenSliceList::usage="FlattenSliceList[slice_] reformats slice data."

SliceValues::usage="SliceValues[slice_] reformats slice data by replacing full 3D data (x,y,z triples) by just z-values."
\

CombineColumns::usage="CombineColumns[list1_,list2_] combines columns from two lists in into a single list, e.g. CombineColumns[{1,2,3},{4,5,6}] will yield {{1,4},{2,5},{3,6}}."
\

Abs0DStructs::usage="Abs0DStructs[re_,im_] computes the absolute value of complex data."
\

Arg0DStructs::usage="Arg0DStructs[re_,im_] computes the phase angle of complex data."
\

Mult0DStructs::usage="Mult0DStructs[list1_,list2_] multiplies data entries from list1 with entries from list2 and combines them into a single list."
\

Add0DStructs::usage ="Add0DStructs[list1_,list2_] adds data entries from list1 and entries from list2 and combines them into a single list."
\

RK2Int::usage="RK2Int[rhs_,dt_] uses RK2 to integrate a list of RHS objects with time step dt."
\

RK2Int2DStruct::"RK2Int2DStruct[struct_] uses RK2 to integrate a BAM 2D time series object in time."
\

RK2Int0DStruct::"RK2Int0DStruct[struct_] uses RK2 to integrate a BAM 0D time series object in time."
\

SurfaceIntegrate::usage="SurfaceIntegrate[timeSeries_] maps a 2D to a 0D time series by 2D integration over the time slices."
\

ReadADMData::usage=
  "ReadADMData[filename] reads BAM ADM_mass format ASCII data and returns them in the form 
  {Times\[Rule] data, MADM\[Rule] data,MADMB\[Rule]  data,
  LinearMomentum\[Rule] data,AngularMomentum\[Rule] data}, where data is a list 
  of single or triple values as appropriate."

ReadLeanPsiData::usage="ReadLeanPsiData[filename] reads LEAN-code psi4 format ASCII data and returns them in the form 
  {Times\[Rule] data, RePsi4\[Rule] data,ImPsi4\[Rule] data,AbsPsi4\[Rule] data}, where data is a list 
  of single or triple values as appropriate."

ReadColData::usage="ReadColData[filename,col] reads ASCII data in column format and returns them
  as a list with col columns."

Read2DPunctureData::usage="Read2DPunctureData[filename] reads BAM 5-column (x,y) moving puncture format ASCII data, extends them to 3D-data assuming movement along the equatiorial pland and returns them in the form 
  {Times\[Rule] data, Position\[Rule] data,Speed\[Rule]  data]}, where data is a list 
  of single or triple values as appropriate."

ReadPunctureData::usage="ReadPunctureData[filename] reads BAM 7-column (x,y,z) moving puncture format ASCII data and returns them in the form 
  {Times\[Rule] data, Position\[Rule] data,Speed\[Rule]  data]}, where data is a list 
  of single or triple values as appropriate."

ReadLeanPunctureData::usage="ReadLeanPunctureData[filename] reads LEAN 4-column (x,y,z) moving puncture format ASCII data and returns them in the form {Times\[Rule] data, Position\[Rule] data,Speed\[Rule]  data]}, where data is a list 
  of single or triple values as appropriate."

MPConcat::usage="MPConcat[mp1,mp2] concatenates moving puncture data structures that correspond to different time windows."
\

ReadQNMData::usage="ReadQNMData[filename] reads Emanuele Berti's 5-column Kerr QNM data in ASCII format and returns them in the form 
  {aKerr\[Rule] data, RealFreq\[Rule] data,ImagFreq\[Rule]  data]}, where data is a list 
  of values."

ReadCenterData::usage="ReadCenterData[filename] reads BAM 5-column alpha_center format ASCII data and returns them in the form 
  {Times\[Rule] data, Lapse\[Rule] data]}, where data is a list 
  of single or triple values as appropriate."

Read0DSets::usage="Read0DSets[basename_,dirs_]  reads 0D data time series from files basename in directories dirs."
\

Read0DSets2::usage="Read0DSets2[basenames_,dirs_]  reads 0D data time series from files basename in directories dirs."
\

Interpolate0DSets::usage="Interpolate0DSets[s_,ord_,t_] creates interpolating functions 
  f[t] of order ord for the sets s."

ConvFact::usage="ConvFact[integerList_,ord_]  computes the 3-level convergence factor
  for a list integerList of gridpoint-numbers and theoretical convergence order ord."
\

Conv3Level0DSets::usage="Conv3Level0DSets[functions_,npoints_,ord_] computes the scaled differences for a 3-level convergence test, with convergence order ord and gridpoint-numbers npoints."
\

Richardson0DFunctions::usage="Richardson0DFunctions[funs_,npoints_,order_] computes the 
  Richardson extrapolation with convergence order ord and gridpoint-numbers npoints from 2 functions funs."
\

Richardson0DFunctionsError::usage="Richardson0DFunctionsError[funs_,npoints_,order_] computes the 
  Richardson extrapolation error with convergence order order and gridpoint-numbers npoints from 3 functions funs."
\

NewsFrom0DPsi4::usage="NewsFrom0DPsi4[repsi4_,impsi4_]compute the news from lists representing the real and imaginary part of psi4."
\

hFrom0DPsi4::usage="hFrom0DPsi4[repsi4_,impsi4_] compute h from lists representing the real and imaginary part of psi4."
\

hFrom0DPsi4B::usage="hFrom0DPsi4B[repsi4_,impsi4_] compute h from lists representing the real and imaginary part of psi4, but allowing for a psi4 that does not start at zero."
\

ADMFit1Rad::usage=
  "ADMFit1Rad[filesres_,order_] analyzes convergence of mass-related quantities for one radius depending on resolution, where filesres
  is a list of the format {{file1, numgridpoints1},{file2,numgridpoints2},...}
  and order is the assumed order of convervence. The last 3 entries are taken for analysis!"
\

ADMFit1Res::usage="ADMFit1Res[filesrad_] analyzes convergence of mass-related quantities for one resolution depending on radius, where filesrad
  is a list of the format {{file1, radius1},{file2,radius2},...}. The last 3 entries are taken for analysis!"
\

WriteNRDA0D::usage="WriteNRDA0D[data1_,data2_,filename_] writes NRDA 3-column format ASCII data."
\

Overlap0DSets::usage="Overlap0DSets[function1_,function2_,minmax_] computes
  the overlap integral for 2 functions function1[t] and function2[t], 
  where minmax has the format {t,tmin,tmax}."

























































Begin["`Private`"];





ReadSphereData[file_]:=
  
  Module[ {inStream,gfRule,GF,radiusRecord,gridRecord,
      thetaMinMaxRecord,phiMinMaxRecord,dthetaRecord,dphiRecord,radius,
      gridDim,grid,times,dtheta,dphi,thetaMin,thetaMax,phiMin,phiMax,
      timeSeries,table,separator,iterationRecord,timeRecord,entry,time,i},
    
    inStream=OpenRead[file];
     
    (* which grid function are we dealing with? *)
    
    GF=ToExpression@StringDrop[Read[inStream,Record],2];
    Print[GF];
    
    (* read meta-data records from file *) 
    radiusRecord=Read[inStream,{Word,Word,Word,Number}];
    gridRecord=Read[inStream,{Word,Word,Word,Expression}];
    thetaMinMaxRecord=
      Read[inStream,{Word,Word,Word,Word,Number,Word,Number,Word}];
    phiMinMaxRecord=
      Read[inStream,{Word,Word,Word,Word,Number,Word,Number,Word}];
    dthetaRecord=Read[inStream,{Word,Word,Word,Number}];
    dphiRecord=Read[inStream,{Word,Word,Word,Number}];
    
    (* assign meta-data variables from file records and print what we got *)
 
       radius=radiusRecord[[4]];
    gridDim={gridRecord[[4]][[1]],gridRecord[[4]][[2]]};
    dtheta=dthetaRecord[[4]];
    dphi=dphiRecord[[4]];
    thetaMin=thetaMinMaxRecord[[5]];
    thetaMax=thetaMinMaxRecord[[7]];
    phiMin=phiMinMaxRecord[[5]];
    phiMax=phiMinMaxRecord[[7]];
    
    
    grid=Table[ { i*dtheta,(j-1)*dphi},
        {i,1,(gridDim[[1]]+1)},
        {j,1(gridDim[[2]]+1)}
        ];
    
    Print[radius];
    Print[gridDim];
    Print[dtheta,"  ",dphi,"   ",thetaMin,"    ",thetaMax];
    Print[phiMin];
    Print[phiMax];
    
    
    (* loop over time steps and read data *)
    times={};
    timeSeries={};
    table={};
    
    While[Not@MemberQ[Flatten@table, EndOfFile],
      
      separator = Read[inStream,Word];
      If [separator\[Equal]EndOfFile, Break[]];
      
      iterationRecord=Read[inStream,{Word,Word,Number}];
      timeRecord            =Read[inStream,{Word,Word,Word,Number}];
      
      iteration=iterationRecord[[3]];
      time=timeRecord[[4]];
      
      table=
        Table[Table[{Read[inStream,Number]},{j,1,(gridDim[[2]]+1)}],{i,
            1(gridDim[[1]]+1)}];
      
      AppendTo[timeSeries,table];
      AppendTo[times,time]
      ];
    
    (* print amount of data read & close stream *)
    
    Print["read to to time step ", iteration, " at time ", time ];
    Print["read ",N[ByteCount@timeSeries / 1024], " KByte of data;"];
    Close[inStream];
    
    (* the result is a list containing meta-data, 
      a list of time stamps and the time series of data *)
    {Radius\[Rule] 
        radius,GridDim\[Rule] gridDim,DX\[Rule] dtheta,DY\[Rule] dphi,
      XMin\[Rule] thetaMin,XMax\[Rule] thetaMax,YMin\[Rule] phiMin,
      YMax\[Rule] phiMax,Grid\[Rule] grid,Times\[Rule] times,
      TimeSeries\[Rule] timeSeries}
    ];











ReadSphereData[file_,steps_]:=
  
  Module[ {inStream,gfRule,GF,radiusRecord,gridRecord,
      thetaMinMaxRecord,phiMinMaxRecord,dthetaRecord,dphiRecord,radius,
      gridDim,grid,times,dtheta,dphi,thetaMin,thetaMax,phiMin,phiMax,
      timeSeries,table,separator,iterationRecord,timeRecord,entry,time,i,
      count},
    
    inStream=OpenRead[file];
     
    (* which grid function are we dealing with? *)
    
    GF=ToExpression@StringDrop[Read[inStream,Record],2];
    Print[GF];
    
    (* read meta-data records from file *) 
    radiusRecord=Read[inStream,{Word,Word,Word,Number}];
    gridRecord=Read[inStream,{Word,Word,Word,Expression}];
    thetaMinMaxRecord=
      Read[inStream,{Word,Word,Word,Word,Number,Word,Number,Word}];
    phiMinMaxRecord=
      Read[inStream,{Word,Word,Word,Word,Number,Word,Number,Word}];
    dthetaRecord=Read[inStream,{Word,Word,Word,Number}];
    dphiRecord=Read[inStream,{Word,Word,Word,Number}];
    
    (* assign meta-data variables from file records and print what we got *)
 
       radius=radiusRecord[[4]];
    gridDim={gridRecord[[4]][[1]],gridRecord[[4]][[2]]};
    dtheta=dthetaRecord[[4]];
    dphi=dphiRecord[[4]];
    thetaMin=thetaMinMaxRecord[[5]];
    thetaMax=thetaMinMaxRecord[[7]];
    phiMin=phiMinMaxRecord[[5]];
    phiMax=phiMinMaxRecord[[7]];
    
    
    grid=Table[ { i*dtheta,(j-1)*dphi},
        {i,1,(gridDim[[1]]+1)},
        {j,1(gridDim[[2]]+1)}
        ];
    
    Print[radius];
    Print[gridDim];
    Print[dtheta,"  ",dphi,"   ",thetaMin,"    ",thetaMax];
    Print[phiMin];
    Print[phiMax];
    
    
    (* loop over time steps and read data *)
    times={};
    timeSeries={};
    table={};
    count=0;
    
    While[Not@MemberQ[Flatten@table, EndOfFile],
      
      count=count+1;
      
      separator = Read[inStream,Word];
      If [separator\[Equal]EndOfFile, Break[]];
      
      iterationRecord=Read[inStream,{Word,Word,Number}];
      timeRecord            =Read[inStream,{Word,Word,Word,Number}];
      
      iteration=iterationRecord[[3]];
      time=timeRecord[[4]];
      
      table=
        Table[Table[{Read[inStream,Number]},{j,1,(gridDim[[2]]+1)}],{i,
            1(gridDim[[1]]+1)}];
      
      
      If[Mod[count,steps]\[Equal]0,
        AppendTo[timeSeries,table];
        AppendTo[times,time];
        ];
      ];
    
    (* print amount of data read & close stream *)
    
    Print["read to to time step ", iteration, " at time ", time ];
    Print["read ",N[ByteCount@timeSeries / 1024], " KByte of data;"];
    Close[inStream];
    
    (* the result is a list containing meta-data, 
      a list of time stamps and the time series of data *)
    {Radius\[Rule] 
        radius,GridDim\[Rule] gridDim,DX\[Rule] dtheta,DY\[Rule] dphi,
      XMin\[Rule] thetaMin,XMax\[Rule] thetaMax,YMin\[Rule] phiMin,
      YMax\[Rule] phiMax,Grid\[Rule] grid,Times\[Rule] times,
      TimeSeries\[Rule] timeSeries}
    ];











Read0DSets[basename_,directories_]:=Module[{len,i},
      
      len =Length@directories;
      
      Table[ReadTimeSeriesData[directories[[i]]<> "/"<>basename],{i,1,len}]
      ];



Read0DSets2[basenames_,directories_]:=Module[{len,i},
      
      len =Length@directories;
      
      Table[
        ReadTimeSeriesData[directories[[i]]<> "/"<>basenames[[i]]],{i,1,len}]
      ];



ReadADMData[file_]:=
    Module[ {inStream,table,rec, throwaway},
      
      inStream=OpenRead[file];
      
      (* we do not need the first two lines *) 
      throwaway=Read[inStream,String];
      throwaway=Read[inStream,String];
      
      (* loop over time steps and read data *)
      rec={};
      table={};
      
      While[!TrueQ[rec\[Equal]  EndOfFile],
        
        rec=Read[inStream,
            {Number,Number,Number,Number,Number,Number,Number,Number,
              Number}];
        
        If[!TrueQ[rec\[Equal]  EndOfFile],AppendTo[table, rec]];
        ];
      
      (* print amount of data read & close stream *)
      
      Print["read ",N[ByteCount@table / 1024], " KByte of data;"];
      Close[inStream];
      
      {Times\[Rule] Column[table,1], 
        MADM\[Rule]  Column[table,2],
        MADMB\[Rule]  Column[table,3],
        LinearMomentum\[Rule]  Column[table,{4,5,6}],
        AngularMomentum\[Rule]  Column[table,{7,8,9}]}
      ];



ReadLeanPsiData[file_]:=
    Module[ {inStream,table,rec, throwaway},
      
      inStream=OpenRead[file];
      
      (* we do not need the first 4 lines *) 
      throwaway=Read[inStream,String];
      throwaway=Read[inStream,String];
      throwaway=Read[inStream,String];
      throwaway=Read[inStream,String];
      
      (* loop over time steps and read data *)
      rec={};
      table={};
      
      While[!TrueQ[rec\[Equal]  EndOfFile],
        
        rec=Read[inStream,
            {Number,Number,Number,Number}];
        
        If[!TrueQ[rec\[Equal]  EndOfFile],AppendTo[table, rec]];
        ];
      
      (* print amount of data read & close stream *)
      
      Print["read ",N[ByteCount@table / 1024], " KByte of data;"];
      Close[inStream];
      
      {Times\[Rule] Column[table,1], 
        RePsi4\[Rule]  Column[table,2],
        ImPsi4\[Rule]  Column[table,3],
        AbsPsi4\[Rule]  Column[table,4]}
      ];



ReadColData[file_,cols_]:=
    
    Module[ {inStream,table,form,ii,rec, throwaway},
      
      form = Table[Number,{ii,1,cols}];
      
      inStream=OpenRead[file];
      
      (* loop over time steps and read data *)
      rec={};
      table={};
      
      While[!TrueQ[rec\[Equal]  EndOfFile],
        
        rec=Read[inStream, form
            ];
        
        If[!TrueQ[rec\[Equal]  EndOfFile],AppendTo[table, rec]];
        ];
      
      (* print amount of data read & close stream *)
      
      Print["read ",N[ByteCount@table / 1024], " KByte of data;"];
      Close[inStream];
      
      table
      ];

ReadColData[file_,cols_,lines_]:=  (* version that skips first lines_ lines *)

        Module[ {inStream,table,form,ii,rec, throwaway},
      
      form = Table[Number,{ii,1,cols}];
      
      inStream=OpenRead[file];
      
      (* we do not need the first lines *)
      
      Do[ throwaway=Read[inStream,String],{lines}];
      
      
      (* loop over time steps and read data *)
      rec={};
      table={};
      
      While[!TrueQ[rec\[Equal]  EndOfFile],
        
        rec=Read[inStream, form
            ];
        
        If[!TrueQ[rec\[Equal]  EndOfFile],AppendTo[table, rec]];
        ];
      
      (* print amount of data read & close stream *)
      
      Print["read ",N[ByteCount@table / 1024], " KByte of data;"];
      Close[inStream];
      
      table
      ];



Read2DPunctureData[file_]:=
    Module[ {inStream,table,rec},
      
      inStream=OpenRead[file];
      
      (* loop over time steps and read data *)
      rec={};
      table={};
      
      While[!TrueQ[rec\[Equal]  EndOfFile],
        
        rec=Read[inStream,
            {Number,Number,Number,Number,Number}];
        
        If[!TrueQ[rec\[Equal]  EndOfFile],
          rec={rec[[1]],rec[[2]],0,rec[[3]],rec[[4]],0,rec[[5]]};
          AppendTo[table, rec]];
        ];
      
      (* print amount of data read & close stream *)
      
      Print["read ",N[ByteCount@table / 1024], " KByte of data;"];
      Close[inStream];
      
      {Times\[Rule] Column[table,7], 
        Position\[Rule]  Column[table,{1,2,3}],
        Speed\[Rule]  Column[table,{4,5,6}]}
      ];



ReadPunctureData[file_]:=
    Module[ {inStream,table,rec},
      
      inStream=OpenRead[file];
      
      (* loop over time steps and read data *)
      rec={};
      table={};
      
      While[!TrueQ[rec\[Equal]  EndOfFile],
        
        rec=Read[inStream,
            {Number,Number,Number,Number,Number,Number,Number}];
        
        If[!TrueQ[rec\[Equal]  EndOfFile],AppendTo[table, rec]];
        ];
      
      (* print amount of data read & close stream *)
      
      Print["read ",N[ByteCount@table / 1024], " KByte of data;"];
      Close[inStream];
      
      {Times\[Rule] Column[table,7], 
        Position\[Rule]  Column[table,{1,2,3}],
        Speed\[Rule]  Column[table,{4,5,6}]}
      ];



ReadLeanPunctureData[file_]:=
    Module[ {inStream,table,rec},
      
      inStream=OpenRead[file];
      
      (* loop over time steps and read data *)
      rec={};
      table={};
      
      While[!TrueQ[rec\[Equal]  EndOfFile],
        
        rec=Read[inStream,
            {Number,Number,Number,Number}];
        
        If[!TrueQ[rec\[Equal]  EndOfFile],AppendTo[table, rec]];
        ];
      
      (* print amount of data read & close stream *)
      
      Print["read ",N[ByteCount@table / 1024], " KByte of data;"];
      Close[inStream];
      
      {Times\[Rule] Column[table,1], 
        Position\[Rule]  Column[table,{2,3,4}]}
      ];



MPConcat[mp1_,mp2_]:=Module[{},
      
      {Times\[Rule]Join[Times/.mp1,Times/.mp2],
        Position\[Rule]Join[Position/.mp1,Position/.mp2],
        Speed\[Rule]Join[Speed/.mp1,Speed/.mp2]}
      ];



ReadQNMData[file_]:=
    Module[ {inStream,table,rec},
      
      inStream=OpenRead[file];
      
      (* loop over time steps and read data *)
      rec={};
      table={};
      
      While[!TrueQ[rec\[Equal]  EndOfFile],
        
        rec=Read[inStream,
            {Number,Number,Number,Number,Number}];
        
        If[!TrueQ[rec\[Equal]  EndOfFile],AppendTo[table, rec]];
        ];
      
      (* print amount of data read & close stream *)
      
      Print["read ",N[ByteCount@table / 1024], " KByte of data;"];
      Close[inStream];
      
      {aKerr\[Rule] Column[table,1], 
        RealFreq\[Rule]  Column[table,2],
        ImagFreq\[Rule]  Column[table,3]}
      ];



ReadCenterData[file_]:=
    Module[ {inStream,table,rec},
      
      inStream=OpenRead[file];
      
      (* loop over time steps and read data *)
      rec={};
      table={};
      
      While[!TrueQ[rec\[Equal]  EndOfFile],
        
        rec=Read[inStream,
            {Number,Number,Number,Number,Number}];
        
        If[!TrueQ[rec\[Equal]  EndOfFile], AppendTo[table, rec]];
        ];
      
      (* print amount of data read & close stream *)
      
      Print["read ",N[ByteCount@table / 1024], " KByte of data;"];
      Close[inStream];
      
      {Times\[Rule] Column[table,1], 
        Lapse\[Rule]  Column[table,2]}
      ];



TimeSeriesToSphereData[data1D_,modFunction_]:=
    Module[ {ts,grid,dim,result,timeSeries,i,j,k},
      
      ts = lookupDefault[data1D, TimeSeries,"undefined"]; 
      grid = lookupDefault[data1D, Grid,"undefined"]; 
      dim= lookupDefault[data1D, GridDim,"undefined"];
      
       timeSeries=Table[ 
           Table[modFunction[[i,j]] * ts[[k]],
            {i,1,(dim[[1]]+1)},
            {j,1,(dim[[2]]+1)}],{k,1,Length@ts}];
      
      Print["created ",N[ByteCount@timeSeries / 1024], " KByte of data"];
      
      result=data1D;
      result[[Length@result]]=TimeSeries\[Rule] timeSeries;
      result
      ];



ReadTimeSeriesData[file_]:=
    Module[ {inStream,timeSeries,entry,time,i,throwaway},
      
      inStream=OpenRead[file];
      
      throwaway=Read[inStream,String];
      
      If [StringMatchQ[throwaway, " *"],
        Close@inStream;
        inStream=OpenRead[file];
        ];
      
      timeSeries={};
      record= {};
      
      While[record != {EndOfFile},
        
         record=Read[inStream,{Number,Number}];
         AppendTo[timeSeries,record];
        ];
      Close[inStream];
      
      Print["read ",N[ByteCount@timeSeries  / 1024], " KByte of data"];
      
      Drop[timeSeries,-1] (* last element is EndOfFile *) 
      ];





Qualify0DData[data0D_,data2D_]:=Module[{result},
      
      result=mapReplace[data2D,TimeSeries,Map[Last,data0D]];
      result=mapReplace[result,Times,Map[First,data0D]]
      ];



GridSlice[timeSeries_,k_]:=Module[{val,grid,result,dx,dy,dim},
      
      dx =lookup[timeSeries,DX];
      dy =lookup[timeSeries,DY];
      
      dim = lookup[timeSeries,GridDim];
      
      val=lookup[timeSeries,TimeSeries][[k]];
      grid=lookup[timeSeries,Grid];
      
      grid = grid /. {i_, j_}\[Rule] { i*dx,(j-1)*dy};
      
      grid=Table[{t,p},
          Evaluate[{t,XMin,XMax+DX,DX}/.Flatten@timeSeries],
          Evaluate[{p,YMin,YMax+DY,DY}/.Flatten@timeSeries]];
      
      result=Table[Flatten@{grid[[i,j]], val[[i,j]]}  ,
          {i,1,(dim[[1]]+1)},
          {j,1,(dim[[2]]+1)} ]
      ];



zero[x_]=0



FlattenSliceList[slice_]:=Module[{result,dim,k},
      
      dim = {Length@slice,Length@slice[[1]]};
      Print["Input array has dimensions ", dim];
      
      result=Array[zero,dim[[1]]  dim[[2]] ];
      
      k=1;
      Do[result[[k]]=slice[[i,j]];k=k+1; ,
        {i,1,dim[[1]]},
        {j,1,dim[[2]]} ];
      
      result
      ];



SliceValues[slice_]:=slice /. {x_,y_,z_}\[Rule] z



CombineColumns[list1_,list2_]:=Module[{len,lendiff},
      
      lendiff=Length@list1-Length@list2;
      If[lendiff < 0, Print["list 1 shorter by ", -lendiff, "elements!"]];
      If[lendiff > 0, Print["list 1 longer by ", lendiff, "elements!"]];
      
      len=Min[Length@list1,Length@list2];
      
      Table[{list1[[i]],list2[[i]]},{i,1,len}]
      ];







Abs0DStructs[re_,im_]:=Module[{revals,imvals,reimvals,times,dt,result},
      
      times=Map[First,re];
      revals=Map[Last,re];
      imvals=Map[Last,im];
      
      reimvals=revals + I imvals;
      reimvals=Abs@reimvals;
      
      result=CombineColumns[times,reimvals]
      ];

Abs0DStructs[reim_]:=Module[{reimvals,times,dt,result},
      
      times=Map[First,reim];
      
      reimvals=Map[Last,reim];
      reimvals=Abs@reimvals;
      
      result=CombineColumns[times,reimvals]
      ];



Arg0DStructs[re_,im_]:=Module[{revals,imvals,reimvals,times,result,i,j,sign},
      
      times=Map[First,re];
      revals=Map[Last,re];
      imvals=Map[Last,im];
      
      reimvals=revals + I imvals;
      reimvals=Arg@reimvals;
      
      Do[
        
        If[( reimvals[[i+1]] -reimvals[[i]] )> (3\[Pi]/4),
          
          (* 
            Print["decrement   ", times[[i]],
                "  ", ( reimvals[[i+1]] -reimvals[[i]] )]; *)
          
          Do[reimvals[[j]]= reimvals[[j]]- 2 \[Pi],{j,i+1,Length@reimvals}];
          ];
        
        If[ TrueQ[(reimvals[[i+1]] -reimvals[[i]] )< (-3\[Pi]/4)],
          sign=1;
          (* Print[ "increment   ", times[[i]]]; *)
          
          Do[reimvals[[j]]= reimvals[[j]]+ 2 \[Pi],{j,i+1,Length@reimvals}];
          ];
        
        , {i,1,Length@reimvals-1}]; 
      
      result=CombineColumns[times,reimvals]
      ];





Mult0DStructs[list1_,list2_]:=Module[{vals1,vals2,vals,times,dt,result},
      
      times=Map[First,list1];
      vals1=Map[Last,list1];
      vals2=Map[Last,list2];
      
      vals=vals1 * vals2;
      
      result=CombineColumns[times,vals]
      ];





Add0DStructs[list1_,list2_]:=Module[{vals1,vals2,vals,times,result},
      
      times=Map[First,list1];
      vals1=Map[Last,list1];
      vals2=Map[Last,list2];
      
      vals=vals1 + vals2;
      
      result=CombineColumns[times,vals]
      ];



WriteNRDA0D[data1_,data2_,name_]:=Module[{args1,args2,i,tab},
      
      args1=Map[First,data1];
      args2=Map[First,data2];
      
      If[Length@data1\[NotEqual]Length@data2,
        Print["data sets have unequal length!"]];
      
      If[Chop@Total[(args1-args2)^2]>0,
        Print["arg mismatch: ",Chop@Total[(args1-args2)^2]];
        ];
      
      tab=
        Table[{args1[[i]],Last@data1[[i]],Last@data2[[i]]},{i,1,
            Length@data1}];
      
      Export[ToString@name,tab,"Table"];
      
      Print["Wrote ",N[ByteCount@tab/1024]," KByte of data to file ",name];
      ];





RK2Int[rhs_,dt_]:=Module[{i, sol},
      
      sol = 0 * rhs; (* create array of correct dimensions *) 
      
      i = 1;
      While[i< Length@rhs,
        
        sol[[i+1]]=sol[[i]]+(dt/2)(rhs[[i]]+rhs[[i+1]]);
        
        i=i+1;
        ];
      
      sol
      ];



RK2Int2DStruct[struct_]:=Module[{vals,times,dt,result},
      
      times=lookup[struct,Times];
      vals=lookup[struct,TimeSeries];
      
      dt = times[[2]]-times[[1]];
      
      result=RK2Int[vals,dt];
      
      result=mapReplace[struct,TimeSeries,result]
      ];



RK2Int0DStruct[struct_]:=Module[{vals,times,dt,result},
      
      times=Map[First,struct];
      vals=Map[Last,struct];
      
      dt = times[[2]]-times[[1]];
      
      result=RK2Int[vals,dt];
      
      result=CombineColumns[times,result]
      ];





SurfaceIntegrate[timeSeries_]:=
    Module[{interp,result,steps,i,ts,integral,theta,phi},
      
      result={};
      steps=Length@lookup[timeSeries,Times];
      
      thetaMin=lookup[timeSeries,XMin];
      thetaMax=lookup[timeSeries,XMax];
      phiMin=lookup[timeSeries,YMin];
      phiMax=lookup[timeSeries,YMax];
      
      i=1;
      While[i\[LessEqual] steps,
        ts=GridSlice[timeSeries,i];
        interp=Interpolation[Flatten[ts,1]];
        
        integral=
          N@Integrate[
              interp[theta,phi] Sin[theta],{theta,thetaMin,thetaMax},{phi,
                phiMin,phiMax}];
        AppendTo[result,integral];
        
        i=i+1;
        ];
      result
      ];







Interpolate0DSets[sets_,order_,t_]:=Module[{len,i},
      
      len =Length@sets;
      
      Table[
        Interpolation[sets[[i]],InterpolationOrder\[Rule] order][t],{i,1,
          len}]
      ];





ConvFact[integerList_,order_]:=Module[{sort},
      
      sort=Sort@integerList;
      
      N@((1 - (sort[[1]]/ sort[[2]])^order)/ ( (sort[[1]]/ sort[[2]])^
                  order- (sort[[1]]/ sort[[3]])^order))
      ];













Conv3Level0DSets[functions_,npoints_,order_]:=Module[{diff12,diff23,cf},
      
      cf=ConvFact[npoints,order];
      
      diff12=functions[[1]]-functions[[2]];
      diff23=functions[[2]]-functions[[3]];
      
      {diff12/cf,diff23}
      ];































Richardson0DFunctions[functions_,npoints_,order_]:=Module[{},
      
      (functions[[1]] npoints[[1]]^order - 
            functions[[2]] npoints[[2]]^order)/( 
          npoints[[1]]^order - npoints[[2]]^order)
      ];



\!\(\(Richardson0DFunctionsError[functions_, npoints_, order_] := Module[{}, \[IndentingNewLine]\[IndentingNewLine]\((\((1/npoints[\([2]\)])\)\^order\ \((\((1/npoints[\([2]\)])\) - \((1/npoints[\([3]\)])\))\)\ \((1/npoints[\([3]\)])\)\^order\ \((functions[\([3]\)]\ \((\(-\((1/npoints[\([1]\)])\)\^order\) + \((1/npoints[\([2]\)])\)\^order)\) + functions[\([2]\)]\ \((\((1/npoints[\([1]\)])\)\^order - \((1/npoints[\([3]\)])\)\^order)\) + functions[\([1]\)]\ \((\(-\((1/npoints[\([2]\)])\)\^order\) + \((1/npoints[\([3]\)])\)\^order)\))\))\)/\((\((\((1/npoints[\([2]\)])\)\^order - \((1/npoints[\([3]\)])\)\^order)\)\ \((\((1/npoints[\([2]\)])\)\^order\ \((\((1/npoints[\([2]\)])\) - \((1/npoints[\([3]\)])\))\)\ \((1/npoints[\([3]\)])\)\^order + \((1/npoints[\([1]\)])\)\^\(1 + order\)\ \((\((1/npoints[\([2]\)])\)\^order - \((1/npoints[\([3]\)])\)\^order)\) + \((1/npoints[\([1]\)])\)\^order\ \((\(-\((1/npoints[\([2]\)])\)\^\(1 + order\)\) + \((1/npoints[\([3]\)])\)\^\(1 + order\))\))\))\)\[IndentingNewLine]];\)\)





NewsFrom0DPsi4[repsi4_,impsi4_]:=Module[{ilist,im},
      
      ilist=repsi4/. {x_,y_}\[Rule] {x,I};
      
      im = Mult0DStructs[ilist,impsi4];
      psi4=Add0DStructs[repsi4,im];
      
      RK2Int0DStruct[psi4]
      ];



hFrom0DPsi4[repsi4_,impsi4_]:=Module[{tmp,dt,offset,ilist,im,re,psi4,times},
      
      avg[list_]:=Total@list/Length@list;
      
      times=Map[First,repsi4];
      
      re=Map[Last,repsi4];
      im=Map[Last,impsi4];
      
      psi4=re + I im;
      
      dt=times[[2]]-times[[1]];
      
      tmp=RK2Int[psi4,dt];
      
      offset=avg@tmp;
      tmp = tmp - offset;
      tmp=RK2Int[tmp,dt];
      
      offset=avg@tmp;
      tmp=tmp - offset;
      
      CombineColumns[times,tmp]
      ];





hFrom0DPsi4B[repsi4_,impsi4_]:=Module[{tmp,dt,offset,ilist,im,re,psi4,times},
      
      avg[list_]:=Total@list/Length@list;
      
      times=Map[First,repsi4];
      
      re=Map[Last,repsi4];
      im=Map[Last,impsi4];
      
      psi4=re + I im;
      
      dt=times[[2]]-times[[1]];
      
      tmp=RK2Int[psi4,dt];
      
      offset=avg@tmp;
      tmp = tmp - offset;
      tmp=RK2Int[tmp,dt];
      
      offset=Last@tmp;
      tmp=tmp - offset;
      
      CombineColumns[times,tmp]
      ];





hFrom0DPsi4[repsi4_,impsi4_,Offset_?ListQ]:=
    Module[{tmp,dt,offset,ilist,im,re,psi4,times},
      
      avg[list_]:=Total@list/Length@list;
      
      times=Map[First,repsi4];
      
      re=Map[Last,repsi4];
      im=Map[Last,impsi4];
      
      psi4=re + I im;
      
      dt=times[[2]]-times[[1]];
      
      tmp=RK2Int[psi4,dt];
      
      offset=If[Offset[[1]],avg@tmp,0];
      tmp = tmp - offset;
      tmp=RK2Int[tmp,dt];
      
      offset=If[Offset[[2]],avg@tmp,0];
      tmp=tmp - offset;
      
      CombineColumns[times,tmp]
      ];







ADMFit1Res[filesradii_,M_]:=
    Module[{items,filenames,radii,admData,i,mInitial,mLast,convTest,r1,r2,r3,
        m1,m2,m3,m1E,m2E,m3E,m12,m13,m23,m12E,m13E,m23E,mrad1,mrad2,mrad3,
        mrad12,mrad13,mrad23},
      
      filenames=Map[First,filesradii];
      radii=Map[Last,filesradii];
      
      items=Length@filenames;
      
      admData=Table[ReadADMData[filenames[[i]]],{i,1,items}];
      
      mInitial=Table[First@(MADM/.admData[[i]]),{i,1,items}]/M;
      mLast=Table[Last@(MADM/.admData[[i]]),{i,1,items}]/M;
      
      r1=radii[[items-2]];
      r2=radii[[items-1]];
      r3=radii[[items]];
      
      m1=mInitial[[items-2]];
      m2=mInitial[[items-1]];
      m3=mInitial[[items]];
      
      m1E=mLast[[items-2]];
      m2E=mLast[[items-1]];
      m3E=mLast[[items]];
      
      convTest=(1-(r1/r2)^n)/((r1/r2)^n-(r1/r3)^n)\[Equal](m1-m2)/(m2-m3);
      Print["Estimated radial convergence factor for ADM mass = ",
        FindRoot[convTest,{n,1}]];
      
      convTest=(1-(r1/r2)^n)/((r1/r2)^n-(r1/r3)^n)\[Equal](m1E-m2E)/(m2E-
                m3E);
      Print["Estimated radial convergence factor for final Bondi mass = ",
        FindRoot[convTest,{n,1}]];
      
      m12=Richardson0DFunctions[{m1,m2},{r1,r2},1];
      m13=Richardson0DFunctions[{m1,m3},{r1,r3},1];
      m23=Richardson0DFunctions[{m2,m3},{r2,r3},1];
      
      m12E=Richardson0DFunctions[{m1E,m2E},{r1,r2},1];
      m13E=Richardson0DFunctions[{m1E,m3E},{r1,r3},1];
      m23E=Richardson0DFunctions[{m2E,m3E},{r2,r3},1];
      
      Print["Results & Richardson extrapolation for ADM mass:",
        "\n 1: ",m1,"\t 1-2: ",m12,
        "\n 2: ",m2,"\t 1-3: ",m13,
        "\n 3: ",m3,"\t 2-3: ",m23,
        "\n final: ", m23, "\[PlusMinus]", Abs[m23-m3], " relative error: ", 
        Abs[m23-m3]/m23
        ];
      
      Print["Results & Richardson extrapolation for final Bondi mass:","\n 1: ",
        m1E,"\t 1-2: ",m12E,
        "\n 2: ",m2E,"\t 1-3: ",m13E,
        "\n 3: ",m3E,"\t 2-3: ",m23E,
        "\n final: ", m23E, "\[PlusMinus]", Abs[m23E-m3E], 
        " relative error: ", Abs[m23E-m3E]/m23E
        ];
      
      mrad1=(m1-m1E)/m1;
      mrad2=(m2-m2E)/m2;
      mrad3=(m3-m3E)/m3;
      
      convTest=(1-(r1/r2)^n)/((r1/r2)^n-(r1/r3)^n)\[Equal](mrad1-
                mrad2)/(mrad2-mrad3);
      Print["Estimated radial convergence factor for radiated energy = ",
        FindRoot[convTest,{n,1}]];
      
      mrad12=Richardson0DFunctions[{mrad1,mrad2},{r1,r2},2];
      mrad13=Richardson0DFunctions[{mrad1,mrad3},{r1,r3},2];
      mrad23=Richardson0DFunctions[{mrad2,mrad3},{r2,r3},2];
      
      Print["Results & Richardson extrapolation for radiated energies:","\n 1: ",
        mrad1,"\t 1-2: ",mrad12,
        "\n 2: ",mrad2,"\t 1-3: ",mrad13,
        "\n 3: ",mrad3,"\t 2-3: ",mrad23,
        "\n final: ", mrad23, "\[PlusMinus]", Abs[mrad23-mrad3], 
        " relative error: ", Abs[mrad23-mrad3]/mrad23
        ];
      ];



ADMFit1Rad[filesres_,order_,M_]:=
    Module[{items,filenames,resolutions,admData,i,mInitial,mLast,convTest,r1,
        r2,r3,m1,m2,m3,m1E,m2E,m3E,m12,m13,m23,m12E,m13E,m23E,mrad1,mrad2,
        mrad3,mrad12,mrad13,mrad23},
      
      filenames=Map[First,filesres];
      resolutions=Map[Last,filesres];
      
      items=Length@filenames;
      
      admData=Table[ReadADMData[filenames[[i]]],{i,1,items}];
      
      mInitial=Table[First@(MADM/.admData[[i]]),{i,1,items}]/M;
      mLast=Table[Last@(MADM/.admData[[i]]),{i,1,items}]/M;
      
      r1=resolutions[[items-2]];
      r2=resolutions[[items-1]];
      r3=resolutions[[items]];
      
      m1=mInitial[[items-2]];
      m2=mInitial[[items-1]];
      m3=mInitial[[items]];
      
      m1E=mLast[[items-2]];
      m2E=mLast[[items-1]];
      m3E=mLast[[items]];
      
      convTest=(1-(r1/r2)^n)/((r1/r2)^n-(r1/r3)^n)\[Equal](m1-m2)/(m2-m3);
      Print["Estimated convergence factor for ADM mass = ",
        FindRoot[convTest,{n,2}]];
      
      convTest=(1-(r1/r2)^n)/((r1/r2)^n-(r1/r3)^n)\[Equal](m1E-m2E)/(m2E-
                m3E);
      Print["Estimated radial convergence factor for final Bondi mass = ",
        FindRoot[convTest,{n,2}]];
      
      m12=Richardson0DFunctions[{m1,m2},{r1,r2},1];
      m13=Richardson0DFunctions[{m1,m3},{r1,r3},1];
      m23=Richardson0DFunctions[{m2,m3},{r2,r3},1];
      
      m12E=Richardson0DFunctions[{m1E,m2E},{r1,r2},1];
      m13E=Richardson0DFunctions[{m1E,m3E},{r1,r3},1];
      m23E=Richardson0DFunctions[{m2E,m3E},{r2,r3},1];
      
      Print["Results & Richardson extrapolation for ADM mass:",
        "\n 1: ",m1,"\t 1-2: ",m12,
        "\n 2: ",m2,"\t 1-3: ",m13,
        "\n 3: ",m3,"\t 2-3: ",m23,
        "\n final: ", m23, "\[PlusMinus]", Abs[m23-m3], " relative error: ", 
        Abs[m23-m3]/m23
        ];
      
      Print["Results & Richardson extrapolation for final Bondi mass:","\n 1: ",
        m1E,"\t 1-2: ",m12E,
        "\n 2: ",m2E,"\t 1-3: ",m13E,
        "\n 3: ",m3E,"\t 2-3: ",m23E,
        "\n final: ", m23E, "\[PlusMinus]", Abs[m23E-m3E], 
        " relative error: ", Abs[m23E-m3E]/m23E
        ];
      
      mrad1=(m1-m1E)/m1;
      mrad2=(m2-m2E)/m2;
      mrad3=(m3-m3E)/m3;
      
      convTest=(1-(r1/r2)^n)/((r1/r2)^n-(r1/r3)^n)\[Equal](mrad1-
                mrad2)/(mrad2-mrad3);
      Print["Estimated radial convergence factor for radiated energy = ",
        FindRoot[convTest,{n,2}]];
      
      mrad12=Richardson0DFunctions[{mrad1,mrad2},{r1,r2},2];
      mrad13=Richardson0DFunctions[{mrad1,mrad3},{r1,r3},2];
      mrad23=Richardson0DFunctions[{mrad2,mrad3},{r2,r3},2];
      
      Print["Results & Richardson extrapolation for radiated energies:","\n 1: ",
        mrad1,"\t 1-2: ",mrad12,
        "\n 2: ",mrad2,"\t 1-3: ",mrad13,
        "\n 3: ",mrad3,"\t 2-3: ",mrad23,
        "\n final: ", mrad23, "\[PlusMinus]", Abs[mrad23-mrad3], 
        " relative error: ", Abs[mrad23-mrad3]/mrad23];
      ];





Overlap0DSets[function1_,function2_,minmax_]:=Module[{x,min,max},
      
      x=minmax[[1]];
      min=minmax[[2]];
      max=minmax[[3]];
      
      NIntegrate[function1*function2,{t,min,max}]
      ];







End[];
EndPackage[];





















































